Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> program function
Rule 3     program -> empty
Rule 4     type -> Int
Rule 5     function -> type Identifier LParen RParen LBrace block RBrace
Rule 6     function -> type Identifier LParen parameter RParen LBrace block RBrace
Rule 7     parameter -> parameter parameter_item
Rule 8     parameter -> empty
Rule 9     parameter_item -> Comma declaration
Rule 10    parameter_item -> declaration
Rule 11    block -> block block_item
Rule 12    block -> empty
Rule 13    block_item -> statement
Rule 14    block_item -> declaration Semi
Rule 15    statement -> statement_matched
Rule 16    statement -> statement_unmatched
Rule 17    statement_matched -> If LParen expression RParen statement_matched Else statement_matched
Rule 18    statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched
Rule 19    statement_unmatched -> If LParen expression RParen statement
Rule 20    statement_matched -> While LParen expression RParen statement_matched
Rule 21    statement_unmatched -> While LParen expression RParen statement_unmatched
Rule 22    statement_matched -> Do statement_matched While expression Semi
Rule 23    statement_unmatched -> Do statement_unmatched While expression Semi
Rule 24    statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched
Rule 25    statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched
Rule 26    statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched
Rule 27    statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched
Rule 28    statement_matched -> For LParen Semi expression Semi expression RParen statement_matched
Rule 29    statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched
Rule 30    statement_matched -> For LParen expression Semi Semi expression RParen statement_matched
Rule 31    statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched
Rule 32    statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched
Rule 33    statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched
Rule 34    statement_matched -> For LParen expression Semi expression Semi RParen statement_matched
Rule 35    statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched
Rule 36    statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched
Rule 37    statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched
Rule 38    statement_matched -> For LParen expression Semi Semi RParen statement_matched
Rule 39    statement_matched -> For LParen declaration Semi Semi RParen statement_matched
Rule 40    statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched
Rule 41    statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched
Rule 42    statement_matched -> For LParen Semi expression Semi RParen statement_matched
Rule 43    statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched
Rule 44    statement_matched -> For LParen Semi Semi expression RParen statement_matched
Rule 45    statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched
Rule 46    statement_matched -> For LParen Semi Semi RParen statement_matched
Rule 47    statement_unmatched -> For LParen Semi Semi RParen statement_unmatched
Rule 48    statement_matched -> Return expression Semi
Rule 49    statement_matched -> opt_expression Semi
Rule 50    statement_matched -> LBrace block RBrace
Rule 51    statement_matched -> Break Semi
Rule 52    statement_matched -> Continue Semi
Rule 53    opt_expression -> expression
Rule 54    opt_expression -> empty
Rule 55    declaration -> type Identifier
Rule 56    declaration -> type Identifier Assign expression
Rule 57    expression -> assignment
Rule 58    assignment -> conditional
Rule 59    conditional -> logical_or
Rule 60    logical_or -> logical_and
Rule 61    logical_and -> bit_or
Rule 62    bit_or -> xor
Rule 63    xor -> bit_and
Rule 64    bit_and -> equality
Rule 65    equality -> relational
Rule 66    relational -> additive
Rule 67    additive -> multiplicative
Rule 68    multiplicative -> unary
Rule 69    unary -> postfix
Rule 70    postfix -> primary
Rule 71    postfix -> Identifier LParen expression_list RParen
Rule 72    expression_list -> expression_list expression_item
Rule 73    expression_list -> empty
Rule 74    expression_item -> Comma expression
Rule 75    expression_item -> expression
Rule 76    unary -> Minus unary
Rule 77    unary -> BitNot unary
Rule 78    unary -> Not unary
Rule 79    assignment -> Identifier Assign expression
Rule 80    logical_or -> logical_or Or logical_and
Rule 81    logical_and -> logical_and And bit_or
Rule 82    bit_or -> bit_or BitOr xor
Rule 83    xor -> xor Xor bit_and
Rule 84    bit_and -> bit_and BitAnd equality
Rule 85    equality -> equality NotEqual relational
Rule 86    equality -> equality Equal relational
Rule 87    relational -> relational Less additive
Rule 88    relational -> relational Greater additive
Rule 89    relational -> relational LessEqual additive
Rule 90    relational -> relational GreaterEqual additive
Rule 91    additive -> additive Plus multiplicative
Rule 92    additive -> additive Minus multiplicative
Rule 93    multiplicative -> multiplicative Mul unary
Rule 94    multiplicative -> multiplicative Div unary
Rule 95    multiplicative -> multiplicative Mod unary
Rule 96    conditional -> logical_or Question expression Colon conditional
Rule 97    primary -> Integer
Rule 98    primary -> Identifier
Rule 99    primary -> LParen expression RParen

Terminals, with rules where they appear

And                  : 81
Assign               : 56 79
BitAnd               : 84
BitNot               : 77
BitOr                : 82
Break                : 51
Colon                : 96
Comma                : 9 74
Continue             : 52
Div                  : 94
Do                   : 22 23
Else                 : 17 18
Equal                : 86
For                  : 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
Greater              : 88
GreaterEqual         : 90
Identifier           : 5 6 55 56 71 79 98
If                   : 17 18 19
Int                  : 4
Integer              : 97
LBrace               : 5 6 50
LParen               : 5 6 17 18 19 20 21 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 71 99
Less                 : 87
LessEqual            : 89
Minus                : 76 92
Mod                  : 95
Mul                  : 93
Not                  : 78
NotEqual             : 85
Or                   : 80
Plus                 : 91
Question             : 96
RBrace               : 5 6 50
RParen               : 5 6 17 18 19 20 21 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 71 99
Return               : 48
Semi                 : 14 22 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 49 51 52
While                : 20 21 22 23
Xor                  : 83
error                : 

Nonterminals, with rules where they appear

additive             : 66 87 88 89 90 91 92
assignment           : 57
bit_and              : 63 83 84
bit_or               : 61 81 82
block                : 5 6 11 50
block_item           : 11
conditional          : 58 96
declaration          : 9 10 14 25 27 31 33 35 37 39 41
empty                : 3 8 12 54 73
equality             : 64 84 85 86
expression           : 17 18 19 20 21 22 23 24 24 24 25 25 26 26 26 27 27 28 28 29 29 30 30 31 32 32 33 34 34 35 36 36 37 38 40 42 43 44 45 48 53 56 74 75 79 96 99
expression_item      : 72
expression_list      : 71 72
function             : 2
logical_and          : 60 80 81
logical_or           : 59 80 96
multiplicative       : 67 91 92 93 94 95
opt_expression       : 49
parameter            : 6 7
parameter_item       : 7
postfix              : 69
primary              : 70
program              : 2 0
relational           : 65 85 86 87 88 89 90
statement            : 13 19
statement_matched    : 15 17 17 18 20 22 24 25 28 30 31 34 35 38 39 42 44 46
statement_unmatched  : 16 18 21 23 26 27 29 32 33 36 37 40 41 43 45 47
type                 : 5 6 55 56
unary                : 68 76 77 78 93 94 95
xor                  : 62 82 83

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . program function
    (3) program -> . empty
    (1) empty -> .

    Int             reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)

    program                        shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> program .
    (2) program -> program . function
    (5) function -> . type Identifier LParen RParen LBrace block RBrace
    (6) function -> . type Identifier LParen parameter RParen LBrace block RBrace
    (4) type -> . Int

    Int             shift and go to state 5

    function                       shift and go to state 3
    type                           shift and go to state 4

state 2

    (3) program -> empty .

    Int             reduce using rule 3 (program -> empty .)
    $end            reduce using rule 3 (program -> empty .)


state 3

    (2) program -> program function .

    Int             reduce using rule 2 (program -> program function .)
    $end            reduce using rule 2 (program -> program function .)


state 4

    (5) function -> type . Identifier LParen RParen LBrace block RBrace
    (6) function -> type . Identifier LParen parameter RParen LBrace block RBrace

    Identifier      shift and go to state 6


state 5

    (4) type -> Int .

    Identifier      reduce using rule 4 (type -> Int .)


state 6

    (5) function -> type Identifier . LParen RParen LBrace block RBrace
    (6) function -> type Identifier . LParen parameter RParen LBrace block RBrace

    LParen          shift and go to state 7


state 7

    (5) function -> type Identifier LParen . RParen LBrace block RBrace
    (6) function -> type Identifier LParen . parameter RParen LBrace block RBrace
    (7) parameter -> . parameter parameter_item
    (8) parameter -> . empty
    (1) empty -> .

  ! shift/reduce conflict for RParen resolved as shift
    RParen          shift and go to state 8
    Comma           reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)

  ! RParen          [ reduce using rule 1 (empty -> .) ]

    parameter                      shift and go to state 9
    empty                          shift and go to state 10

state 8

    (5) function -> type Identifier LParen RParen . LBrace block RBrace

    LBrace          shift and go to state 11


state 9

    (6) function -> type Identifier LParen parameter . RParen LBrace block RBrace
    (7) parameter -> parameter . parameter_item
    (9) parameter_item -> . Comma declaration
    (10) parameter_item -> . declaration
    (55) declaration -> . type Identifier
    (56) declaration -> . type Identifier Assign expression
    (4) type -> . Int

    RParen          shift and go to state 13
    Comma           shift and go to state 15
    Int             shift and go to state 5

    type                           shift and go to state 12
    parameter_item                 shift and go to state 14
    declaration                    shift and go to state 16

state 10

    (8) parameter -> empty .

    RParen          reduce using rule 8 (parameter -> empty .)
    Comma           reduce using rule 8 (parameter -> empty .)
    Int             reduce using rule 8 (parameter -> empty .)


state 11

    (5) function -> type Identifier LParen RParen LBrace . block RBrace
    (11) block -> . block block_item
    (12) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 17
    empty                          shift and go to state 18

state 12

    (55) declaration -> type . Identifier
    (56) declaration -> type . Identifier Assign expression

    Identifier      shift and go to state 19


state 13

    (6) function -> type Identifier LParen parameter RParen . LBrace block RBrace

    LBrace          shift and go to state 20


state 14

    (7) parameter -> parameter parameter_item .

    RParen          reduce using rule 7 (parameter -> parameter parameter_item .)
    Comma           reduce using rule 7 (parameter -> parameter parameter_item .)
    Int             reduce using rule 7 (parameter -> parameter parameter_item .)


state 15

    (9) parameter_item -> Comma . declaration
    (55) declaration -> . type Identifier
    (56) declaration -> . type Identifier Assign expression
    (4) type -> . Int

    Int             shift and go to state 5

    declaration                    shift and go to state 21
    type                           shift and go to state 12

state 16

    (10) parameter_item -> declaration .

    RParen          reduce using rule 10 (parameter_item -> declaration .)
    Comma           reduce using rule 10 (parameter_item -> declaration .)
    Int             reduce using rule 10 (parameter_item -> declaration .)


state 17

    (5) function -> type Identifier LParen RParen LBrace block . RBrace
    (11) block -> block . block_item
    (13) block_item -> . statement
    (14) block_item -> . declaration Semi
    (15) statement -> . statement_matched
    (16) statement -> . statement_unmatched
    (55) declaration -> . type Identifier
    (56) declaration -> . type Identifier Assign expression
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (4) type -> . Int
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    RBrace          shift and go to state 25
    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Int             shift and go to state 5
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    type                           shift and go to state 12
    block_item                     shift and go to state 26
    statement                      shift and go to state 27
    declaration                    shift and go to state 28
    statement_matched              shift and go to state 29
    statement_unmatched            shift and go to state 30
    expression                     shift and go to state 31
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 18

    (12) block -> empty .

    RBrace          reduce using rule 12 (block -> empty .)
    If              reduce using rule 12 (block -> empty .)
    While           reduce using rule 12 (block -> empty .)
    Do              reduce using rule 12 (block -> empty .)
    For             reduce using rule 12 (block -> empty .)
    Return          reduce using rule 12 (block -> empty .)
    LBrace          reduce using rule 12 (block -> empty .)
    Break           reduce using rule 12 (block -> empty .)
    Continue        reduce using rule 12 (block -> empty .)
    Int             reduce using rule 12 (block -> empty .)
    Identifier      reduce using rule 12 (block -> empty .)
    Minus           reduce using rule 12 (block -> empty .)
    BitNot          reduce using rule 12 (block -> empty .)
    Not             reduce using rule 12 (block -> empty .)
    Integer         reduce using rule 12 (block -> empty .)
    LParen          reduce using rule 12 (block -> empty .)
    Semi            reduce using rule 12 (block -> empty .)


state 19

    (55) declaration -> type Identifier .
    (56) declaration -> type Identifier . Assign expression

    RParen          reduce using rule 55 (declaration -> type Identifier .)
    Comma           reduce using rule 55 (declaration -> type Identifier .)
    Int             reduce using rule 55 (declaration -> type Identifier .)
    Semi            reduce using rule 55 (declaration -> type Identifier .)
    Assign          shift and go to state 59


state 20

    (6) function -> type Identifier LParen parameter RParen LBrace . block RBrace
    (11) block -> . block block_item
    (12) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 60
    empty                          shift and go to state 18

state 21

    (9) parameter_item -> Comma declaration .

    RParen          reduce using rule 9 (parameter_item -> Comma declaration .)
    Comma           reduce using rule 9 (parameter_item -> Comma declaration .)
    Int             reduce using rule 9 (parameter_item -> Comma declaration .)


state 22

    (79) assignment -> Identifier . Assign expression
    (71) postfix -> Identifier . LParen expression_list RParen
    (98) primary -> Identifier .

  ! shift/reduce conflict for LParen resolved as shift
    Assign          shift and go to state 61
    LParen          shift and go to state 62
    Mul             reduce using rule 98 (primary -> Identifier .)
    Div             reduce using rule 98 (primary -> Identifier .)
    Mod             reduce using rule 98 (primary -> Identifier .)
    Plus            reduce using rule 98 (primary -> Identifier .)
    Minus           reduce using rule 98 (primary -> Identifier .)
    Less            reduce using rule 98 (primary -> Identifier .)
    Greater         reduce using rule 98 (primary -> Identifier .)
    LessEqual       reduce using rule 98 (primary -> Identifier .)
    GreaterEqual    reduce using rule 98 (primary -> Identifier .)
    NotEqual        reduce using rule 98 (primary -> Identifier .)
    Equal           reduce using rule 98 (primary -> Identifier .)
    BitAnd          reduce using rule 98 (primary -> Identifier .)
    Xor             reduce using rule 98 (primary -> Identifier .)
    BitOr           reduce using rule 98 (primary -> Identifier .)
    And             reduce using rule 98 (primary -> Identifier .)
    Question        reduce using rule 98 (primary -> Identifier .)
    Or              reduce using rule 98 (primary -> Identifier .)
    Semi            reduce using rule 98 (primary -> Identifier .)
    RParen          reduce using rule 98 (primary -> Identifier .)
    Comma           reduce using rule 98 (primary -> Identifier .)
    Int             reduce using rule 98 (primary -> Identifier .)
    Colon           reduce using rule 98 (primary -> Identifier .)
    Identifier      reduce using rule 98 (primary -> Identifier .)
    BitNot          reduce using rule 98 (primary -> Identifier .)
    Not             reduce using rule 98 (primary -> Identifier .)
    Integer         reduce using rule 98 (primary -> Identifier .)

  ! LParen          [ reduce using rule 98 (primary -> Identifier .) ]


state 23

    (99) primary -> LParen . expression RParen
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 63
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 24

    (50) statement_matched -> LBrace . block RBrace
    (11) block -> . block block_item
    (12) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 64
    empty                          shift and go to state 18

state 25

    (5) function -> type Identifier LParen RParen LBrace block RBrace .

    Int             reduce using rule 5 (function -> type Identifier LParen RParen LBrace block RBrace .)
    $end            reduce using rule 5 (function -> type Identifier LParen RParen LBrace block RBrace .)


state 26

    (11) block -> block block_item .

    RBrace          reduce using rule 11 (block -> block block_item .)
    If              reduce using rule 11 (block -> block block_item .)
    While           reduce using rule 11 (block -> block block_item .)
    Do              reduce using rule 11 (block -> block block_item .)
    For             reduce using rule 11 (block -> block block_item .)
    Return          reduce using rule 11 (block -> block block_item .)
    LBrace          reduce using rule 11 (block -> block block_item .)
    Break           reduce using rule 11 (block -> block block_item .)
    Continue        reduce using rule 11 (block -> block block_item .)
    Int             reduce using rule 11 (block -> block block_item .)
    Identifier      reduce using rule 11 (block -> block block_item .)
    Minus           reduce using rule 11 (block -> block block_item .)
    BitNot          reduce using rule 11 (block -> block block_item .)
    Not             reduce using rule 11 (block -> block block_item .)
    Integer         reduce using rule 11 (block -> block block_item .)
    LParen          reduce using rule 11 (block -> block block_item .)
    Semi            reduce using rule 11 (block -> block block_item .)


state 27

    (13) block_item -> statement .

    RBrace          reduce using rule 13 (block_item -> statement .)
    If              reduce using rule 13 (block_item -> statement .)
    While           reduce using rule 13 (block_item -> statement .)
    Do              reduce using rule 13 (block_item -> statement .)
    For             reduce using rule 13 (block_item -> statement .)
    Return          reduce using rule 13 (block_item -> statement .)
    LBrace          reduce using rule 13 (block_item -> statement .)
    Break           reduce using rule 13 (block_item -> statement .)
    Continue        reduce using rule 13 (block_item -> statement .)
    Int             reduce using rule 13 (block_item -> statement .)
    Identifier      reduce using rule 13 (block_item -> statement .)
    Minus           reduce using rule 13 (block_item -> statement .)
    BitNot          reduce using rule 13 (block_item -> statement .)
    Not             reduce using rule 13 (block_item -> statement .)
    Integer         reduce using rule 13 (block_item -> statement .)
    LParen          reduce using rule 13 (block_item -> statement .)
    Semi            reduce using rule 13 (block_item -> statement .)


state 28

    (14) block_item -> declaration . Semi

    Semi            shift and go to state 65


state 29

    (15) statement -> statement_matched .

    RBrace          reduce using rule 15 (statement -> statement_matched .)
    If              reduce using rule 15 (statement -> statement_matched .)
    While           reduce using rule 15 (statement -> statement_matched .)
    Do              reduce using rule 15 (statement -> statement_matched .)
    For             reduce using rule 15 (statement -> statement_matched .)
    Return          reduce using rule 15 (statement -> statement_matched .)
    LBrace          reduce using rule 15 (statement -> statement_matched .)
    Break           reduce using rule 15 (statement -> statement_matched .)
    Continue        reduce using rule 15 (statement -> statement_matched .)
    Int             reduce using rule 15 (statement -> statement_matched .)
    Identifier      reduce using rule 15 (statement -> statement_matched .)
    Minus           reduce using rule 15 (statement -> statement_matched .)
    BitNot          reduce using rule 15 (statement -> statement_matched .)
    Not             reduce using rule 15 (statement -> statement_matched .)
    Integer         reduce using rule 15 (statement -> statement_matched .)
    LParen          reduce using rule 15 (statement -> statement_matched .)
    Semi            reduce using rule 15 (statement -> statement_matched .)


state 30

    (16) statement -> statement_unmatched .

    RBrace          reduce using rule 16 (statement -> statement_unmatched .)
    If              reduce using rule 16 (statement -> statement_unmatched .)
    While           reduce using rule 16 (statement -> statement_unmatched .)
    Do              reduce using rule 16 (statement -> statement_unmatched .)
    For             reduce using rule 16 (statement -> statement_unmatched .)
    Return          reduce using rule 16 (statement -> statement_unmatched .)
    LBrace          reduce using rule 16 (statement -> statement_unmatched .)
    Break           reduce using rule 16 (statement -> statement_unmatched .)
    Continue        reduce using rule 16 (statement -> statement_unmatched .)
    Int             reduce using rule 16 (statement -> statement_unmatched .)
    Identifier      reduce using rule 16 (statement -> statement_unmatched .)
    Minus           reduce using rule 16 (statement -> statement_unmatched .)
    BitNot          reduce using rule 16 (statement -> statement_unmatched .)
    Not             reduce using rule 16 (statement -> statement_unmatched .)
    Integer         reduce using rule 16 (statement -> statement_unmatched .)
    LParen          reduce using rule 16 (statement -> statement_unmatched .)
    Semi            reduce using rule 16 (statement -> statement_unmatched .)


state 31

    (53) opt_expression -> expression .

    Semi            reduce using rule 53 (opt_expression -> expression .)


state 32

    (17) statement_matched -> If . LParen expression RParen statement_matched Else statement_matched
    (18) statement_unmatched -> If . LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> If . LParen expression RParen statement

    LParen          shift and go to state 66


state 33

    (20) statement_matched -> While . LParen expression RParen statement_matched
    (21) statement_unmatched -> While . LParen expression RParen statement_unmatched

    LParen          shift and go to state 67


state 34

    (22) statement_matched -> Do . statement_matched While expression Semi
    (23) statement_unmatched -> Do . statement_unmatched While expression Semi
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    statement_matched              shift and go to state 68
    expression                     shift and go to state 31
    statement_unmatched            shift and go to state 69
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 35

    (24) statement_matched -> For . LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> For . LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> For . LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> For . LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> For . LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> For . LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> For . LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> For . LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> For . LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> For . LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> For . LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> For . LParen Semi Semi RParen statement_matched
    (26) statement_unmatched -> For . LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> For . LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> For . LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> For . LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> For . LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> For . LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> For . LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> For . LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> For . LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> For . LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> For . LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> For . LParen Semi Semi RParen statement_unmatched

    LParen          shift and go to state 70


state 36

    (48) statement_matched -> Return . expression Semi
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 71
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 37

    (49) statement_matched -> opt_expression . Semi

    Semi            shift and go to state 72


state 38

    (51) statement_matched -> Break . Semi

    Semi            shift and go to state 73


state 39

    (52) statement_matched -> Continue . Semi

    Semi            shift and go to state 74


state 40

    (54) opt_expression -> empty .

    Semi            reduce using rule 54 (opt_expression -> empty .)


state 41

    (57) expression -> assignment .

    Semi            reduce using rule 57 (expression -> assignment .)
    RParen          reduce using rule 57 (expression -> assignment .)
    Comma           reduce using rule 57 (expression -> assignment .)
    Int             reduce using rule 57 (expression -> assignment .)
    Colon           reduce using rule 57 (expression -> assignment .)
    Identifier      reduce using rule 57 (expression -> assignment .)
    Minus           reduce using rule 57 (expression -> assignment .)
    BitNot          reduce using rule 57 (expression -> assignment .)
    Not             reduce using rule 57 (expression -> assignment .)
    Integer         reduce using rule 57 (expression -> assignment .)
    LParen          reduce using rule 57 (expression -> assignment .)


state 42

    (58) assignment -> conditional .

    Semi            reduce using rule 58 (assignment -> conditional .)
    RParen          reduce using rule 58 (assignment -> conditional .)
    Comma           reduce using rule 58 (assignment -> conditional .)
    Int             reduce using rule 58 (assignment -> conditional .)
    Colon           reduce using rule 58 (assignment -> conditional .)
    Identifier      reduce using rule 58 (assignment -> conditional .)
    Minus           reduce using rule 58 (assignment -> conditional .)
    BitNot          reduce using rule 58 (assignment -> conditional .)
    Not             reduce using rule 58 (assignment -> conditional .)
    Integer         reduce using rule 58 (assignment -> conditional .)
    LParen          reduce using rule 58 (assignment -> conditional .)


state 43

    (59) conditional -> logical_or .
    (96) conditional -> logical_or . Question expression Colon conditional
    (80) logical_or -> logical_or . Or logical_and

    Semi            reduce using rule 59 (conditional -> logical_or .)
    RParen          reduce using rule 59 (conditional -> logical_or .)
    Comma           reduce using rule 59 (conditional -> logical_or .)
    Int             reduce using rule 59 (conditional -> logical_or .)
    Colon           reduce using rule 59 (conditional -> logical_or .)
    Identifier      reduce using rule 59 (conditional -> logical_or .)
    Minus           reduce using rule 59 (conditional -> logical_or .)
    BitNot          reduce using rule 59 (conditional -> logical_or .)
    Not             reduce using rule 59 (conditional -> logical_or .)
    Integer         reduce using rule 59 (conditional -> logical_or .)
    LParen          reduce using rule 59 (conditional -> logical_or .)
    Question        shift and go to state 75
    Or              shift and go to state 76


state 44

    (60) logical_or -> logical_and .
    (81) logical_and -> logical_and . And bit_or

    Question        reduce using rule 60 (logical_or -> logical_and .)
    Or              reduce using rule 60 (logical_or -> logical_and .)
    Semi            reduce using rule 60 (logical_or -> logical_and .)
    RParen          reduce using rule 60 (logical_or -> logical_and .)
    Comma           reduce using rule 60 (logical_or -> logical_and .)
    Int             reduce using rule 60 (logical_or -> logical_and .)
    Colon           reduce using rule 60 (logical_or -> logical_and .)
    Identifier      reduce using rule 60 (logical_or -> logical_and .)
    Minus           reduce using rule 60 (logical_or -> logical_and .)
    BitNot          reduce using rule 60 (logical_or -> logical_and .)
    Not             reduce using rule 60 (logical_or -> logical_and .)
    Integer         reduce using rule 60 (logical_or -> logical_and .)
    LParen          reduce using rule 60 (logical_or -> logical_and .)
    And             shift and go to state 77


state 45

    (61) logical_and -> bit_or .
    (82) bit_or -> bit_or . BitOr xor

    And             reduce using rule 61 (logical_and -> bit_or .)
    Question        reduce using rule 61 (logical_and -> bit_or .)
    Or              reduce using rule 61 (logical_and -> bit_or .)
    Semi            reduce using rule 61 (logical_and -> bit_or .)
    RParen          reduce using rule 61 (logical_and -> bit_or .)
    Comma           reduce using rule 61 (logical_and -> bit_or .)
    Int             reduce using rule 61 (logical_and -> bit_or .)
    Colon           reduce using rule 61 (logical_and -> bit_or .)
    Identifier      reduce using rule 61 (logical_and -> bit_or .)
    Minus           reduce using rule 61 (logical_and -> bit_or .)
    BitNot          reduce using rule 61 (logical_and -> bit_or .)
    Not             reduce using rule 61 (logical_and -> bit_or .)
    Integer         reduce using rule 61 (logical_and -> bit_or .)
    LParen          reduce using rule 61 (logical_and -> bit_or .)
    BitOr           shift and go to state 78


state 46

    (62) bit_or -> xor .
    (83) xor -> xor . Xor bit_and

    BitOr           reduce using rule 62 (bit_or -> xor .)
    And             reduce using rule 62 (bit_or -> xor .)
    Question        reduce using rule 62 (bit_or -> xor .)
    Or              reduce using rule 62 (bit_or -> xor .)
    Semi            reduce using rule 62 (bit_or -> xor .)
    RParen          reduce using rule 62 (bit_or -> xor .)
    Comma           reduce using rule 62 (bit_or -> xor .)
    Int             reduce using rule 62 (bit_or -> xor .)
    Colon           reduce using rule 62 (bit_or -> xor .)
    Identifier      reduce using rule 62 (bit_or -> xor .)
    Minus           reduce using rule 62 (bit_or -> xor .)
    BitNot          reduce using rule 62 (bit_or -> xor .)
    Not             reduce using rule 62 (bit_or -> xor .)
    Integer         reduce using rule 62 (bit_or -> xor .)
    LParen          reduce using rule 62 (bit_or -> xor .)
    Xor             shift and go to state 79


state 47

    (63) xor -> bit_and .
    (84) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 63 (xor -> bit_and .)
    BitOr           reduce using rule 63 (xor -> bit_and .)
    And             reduce using rule 63 (xor -> bit_and .)
    Question        reduce using rule 63 (xor -> bit_and .)
    Or              reduce using rule 63 (xor -> bit_and .)
    Semi            reduce using rule 63 (xor -> bit_and .)
    RParen          reduce using rule 63 (xor -> bit_and .)
    Comma           reduce using rule 63 (xor -> bit_and .)
    Int             reduce using rule 63 (xor -> bit_and .)
    Colon           reduce using rule 63 (xor -> bit_and .)
    Identifier      reduce using rule 63 (xor -> bit_and .)
    Minus           reduce using rule 63 (xor -> bit_and .)
    BitNot          reduce using rule 63 (xor -> bit_and .)
    Not             reduce using rule 63 (xor -> bit_and .)
    Integer         reduce using rule 63 (xor -> bit_and .)
    LParen          reduce using rule 63 (xor -> bit_and .)
    BitAnd          shift and go to state 80


state 48

    (64) bit_and -> equality .
    (85) equality -> equality . NotEqual relational
    (86) equality -> equality . Equal relational

    BitAnd          reduce using rule 64 (bit_and -> equality .)
    Xor             reduce using rule 64 (bit_and -> equality .)
    BitOr           reduce using rule 64 (bit_and -> equality .)
    And             reduce using rule 64 (bit_and -> equality .)
    Question        reduce using rule 64 (bit_and -> equality .)
    Or              reduce using rule 64 (bit_and -> equality .)
    Semi            reduce using rule 64 (bit_and -> equality .)
    RParen          reduce using rule 64 (bit_and -> equality .)
    Comma           reduce using rule 64 (bit_and -> equality .)
    Int             reduce using rule 64 (bit_and -> equality .)
    Colon           reduce using rule 64 (bit_and -> equality .)
    Identifier      reduce using rule 64 (bit_and -> equality .)
    Minus           reduce using rule 64 (bit_and -> equality .)
    BitNot          reduce using rule 64 (bit_and -> equality .)
    Not             reduce using rule 64 (bit_and -> equality .)
    Integer         reduce using rule 64 (bit_and -> equality .)
    LParen          reduce using rule 64 (bit_and -> equality .)
    NotEqual        shift and go to state 81
    Equal           shift and go to state 82


state 49

    (65) equality -> relational .
    (87) relational -> relational . Less additive
    (88) relational -> relational . Greater additive
    (89) relational -> relational . LessEqual additive
    (90) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 65 (equality -> relational .)
    Equal           reduce using rule 65 (equality -> relational .)
    BitAnd          reduce using rule 65 (equality -> relational .)
    Xor             reduce using rule 65 (equality -> relational .)
    BitOr           reduce using rule 65 (equality -> relational .)
    And             reduce using rule 65 (equality -> relational .)
    Question        reduce using rule 65 (equality -> relational .)
    Or              reduce using rule 65 (equality -> relational .)
    Semi            reduce using rule 65 (equality -> relational .)
    RParen          reduce using rule 65 (equality -> relational .)
    Comma           reduce using rule 65 (equality -> relational .)
    Int             reduce using rule 65 (equality -> relational .)
    Colon           reduce using rule 65 (equality -> relational .)
    Identifier      reduce using rule 65 (equality -> relational .)
    Minus           reduce using rule 65 (equality -> relational .)
    BitNot          reduce using rule 65 (equality -> relational .)
    Not             reduce using rule 65 (equality -> relational .)
    Integer         reduce using rule 65 (equality -> relational .)
    LParen          reduce using rule 65 (equality -> relational .)
    Less            shift and go to state 83
    Greater         shift and go to state 84
    LessEqual       shift and go to state 85
    GreaterEqual    shift and go to state 86


state 50

    (66) relational -> additive .
    (91) additive -> additive . Plus multiplicative
    (92) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 66 (relational -> additive .)
    Greater         reduce using rule 66 (relational -> additive .)
    LessEqual       reduce using rule 66 (relational -> additive .)
    GreaterEqual    reduce using rule 66 (relational -> additive .)
    NotEqual        reduce using rule 66 (relational -> additive .)
    Equal           reduce using rule 66 (relational -> additive .)
    BitAnd          reduce using rule 66 (relational -> additive .)
    Xor             reduce using rule 66 (relational -> additive .)
    BitOr           reduce using rule 66 (relational -> additive .)
    And             reduce using rule 66 (relational -> additive .)
    Question        reduce using rule 66 (relational -> additive .)
    Or              reduce using rule 66 (relational -> additive .)
    Semi            reduce using rule 66 (relational -> additive .)
    RParen          reduce using rule 66 (relational -> additive .)
    Comma           reduce using rule 66 (relational -> additive .)
    Int             reduce using rule 66 (relational -> additive .)
    Colon           reduce using rule 66 (relational -> additive .)
    Identifier      reduce using rule 66 (relational -> additive .)
    BitNot          reduce using rule 66 (relational -> additive .)
    Not             reduce using rule 66 (relational -> additive .)
    Integer         reduce using rule 66 (relational -> additive .)
    LParen          reduce using rule 66 (relational -> additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88

  ! Minus           [ reduce using rule 66 (relational -> additive .) ]


state 51

    (67) additive -> multiplicative .
    (93) multiplicative -> multiplicative . Mul unary
    (94) multiplicative -> multiplicative . Div unary
    (95) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 67 (additive -> multiplicative .)
    Minus           reduce using rule 67 (additive -> multiplicative .)
    Less            reduce using rule 67 (additive -> multiplicative .)
    Greater         reduce using rule 67 (additive -> multiplicative .)
    LessEqual       reduce using rule 67 (additive -> multiplicative .)
    GreaterEqual    reduce using rule 67 (additive -> multiplicative .)
    NotEqual        reduce using rule 67 (additive -> multiplicative .)
    Equal           reduce using rule 67 (additive -> multiplicative .)
    BitAnd          reduce using rule 67 (additive -> multiplicative .)
    Xor             reduce using rule 67 (additive -> multiplicative .)
    BitOr           reduce using rule 67 (additive -> multiplicative .)
    And             reduce using rule 67 (additive -> multiplicative .)
    Question        reduce using rule 67 (additive -> multiplicative .)
    Or              reduce using rule 67 (additive -> multiplicative .)
    Semi            reduce using rule 67 (additive -> multiplicative .)
    RParen          reduce using rule 67 (additive -> multiplicative .)
    Comma           reduce using rule 67 (additive -> multiplicative .)
    Int             reduce using rule 67 (additive -> multiplicative .)
    Colon           reduce using rule 67 (additive -> multiplicative .)
    Identifier      reduce using rule 67 (additive -> multiplicative .)
    BitNot          reduce using rule 67 (additive -> multiplicative .)
    Not             reduce using rule 67 (additive -> multiplicative .)
    Integer         reduce using rule 67 (additive -> multiplicative .)
    LParen          reduce using rule 67 (additive -> multiplicative .)
    Mul             shift and go to state 89
    Div             shift and go to state 90
    Mod             shift and go to state 91


state 52

    (76) unary -> Minus . unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    unary                          shift and go to state 92
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 53

    (68) multiplicative -> unary .

    Mul             reduce using rule 68 (multiplicative -> unary .)
    Div             reduce using rule 68 (multiplicative -> unary .)
    Mod             reduce using rule 68 (multiplicative -> unary .)
    Plus            reduce using rule 68 (multiplicative -> unary .)
    Minus           reduce using rule 68 (multiplicative -> unary .)
    Less            reduce using rule 68 (multiplicative -> unary .)
    Greater         reduce using rule 68 (multiplicative -> unary .)
    LessEqual       reduce using rule 68 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 68 (multiplicative -> unary .)
    NotEqual        reduce using rule 68 (multiplicative -> unary .)
    Equal           reduce using rule 68 (multiplicative -> unary .)
    BitAnd          reduce using rule 68 (multiplicative -> unary .)
    Xor             reduce using rule 68 (multiplicative -> unary .)
    BitOr           reduce using rule 68 (multiplicative -> unary .)
    And             reduce using rule 68 (multiplicative -> unary .)
    Question        reduce using rule 68 (multiplicative -> unary .)
    Or              reduce using rule 68 (multiplicative -> unary .)
    Semi            reduce using rule 68 (multiplicative -> unary .)
    RParen          reduce using rule 68 (multiplicative -> unary .)
    Comma           reduce using rule 68 (multiplicative -> unary .)
    Int             reduce using rule 68 (multiplicative -> unary .)
    Colon           reduce using rule 68 (multiplicative -> unary .)
    Identifier      reduce using rule 68 (multiplicative -> unary .)
    BitNot          reduce using rule 68 (multiplicative -> unary .)
    Not             reduce using rule 68 (multiplicative -> unary .)
    Integer         reduce using rule 68 (multiplicative -> unary .)
    LParen          reduce using rule 68 (multiplicative -> unary .)


state 54

    (69) unary -> postfix .

    Mul             reduce using rule 69 (unary -> postfix .)
    Div             reduce using rule 69 (unary -> postfix .)
    Mod             reduce using rule 69 (unary -> postfix .)
    Plus            reduce using rule 69 (unary -> postfix .)
    Minus           reduce using rule 69 (unary -> postfix .)
    Less            reduce using rule 69 (unary -> postfix .)
    Greater         reduce using rule 69 (unary -> postfix .)
    LessEqual       reduce using rule 69 (unary -> postfix .)
    GreaterEqual    reduce using rule 69 (unary -> postfix .)
    NotEqual        reduce using rule 69 (unary -> postfix .)
    Equal           reduce using rule 69 (unary -> postfix .)
    BitAnd          reduce using rule 69 (unary -> postfix .)
    Xor             reduce using rule 69 (unary -> postfix .)
    BitOr           reduce using rule 69 (unary -> postfix .)
    And             reduce using rule 69 (unary -> postfix .)
    Question        reduce using rule 69 (unary -> postfix .)
    Or              reduce using rule 69 (unary -> postfix .)
    Semi            reduce using rule 69 (unary -> postfix .)
    RParen          reduce using rule 69 (unary -> postfix .)
    Comma           reduce using rule 69 (unary -> postfix .)
    Int             reduce using rule 69 (unary -> postfix .)
    Colon           reduce using rule 69 (unary -> postfix .)
    Identifier      reduce using rule 69 (unary -> postfix .)
    BitNot          reduce using rule 69 (unary -> postfix .)
    Not             reduce using rule 69 (unary -> postfix .)
    Integer         reduce using rule 69 (unary -> postfix .)
    LParen          reduce using rule 69 (unary -> postfix .)


state 55

    (77) unary -> BitNot . unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    unary                          shift and go to state 94
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 56

    (78) unary -> Not . unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    unary                          shift and go to state 95
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 57

    (70) postfix -> primary .

    Mul             reduce using rule 70 (postfix -> primary .)
    Div             reduce using rule 70 (postfix -> primary .)
    Mod             reduce using rule 70 (postfix -> primary .)
    Plus            reduce using rule 70 (postfix -> primary .)
    Minus           reduce using rule 70 (postfix -> primary .)
    Less            reduce using rule 70 (postfix -> primary .)
    Greater         reduce using rule 70 (postfix -> primary .)
    LessEqual       reduce using rule 70 (postfix -> primary .)
    GreaterEqual    reduce using rule 70 (postfix -> primary .)
    NotEqual        reduce using rule 70 (postfix -> primary .)
    Equal           reduce using rule 70 (postfix -> primary .)
    BitAnd          reduce using rule 70 (postfix -> primary .)
    Xor             reduce using rule 70 (postfix -> primary .)
    BitOr           reduce using rule 70 (postfix -> primary .)
    And             reduce using rule 70 (postfix -> primary .)
    Question        reduce using rule 70 (postfix -> primary .)
    Or              reduce using rule 70 (postfix -> primary .)
    Semi            reduce using rule 70 (postfix -> primary .)
    RParen          reduce using rule 70 (postfix -> primary .)
    Comma           reduce using rule 70 (postfix -> primary .)
    Int             reduce using rule 70 (postfix -> primary .)
    Colon           reduce using rule 70 (postfix -> primary .)
    Identifier      reduce using rule 70 (postfix -> primary .)
    BitNot          reduce using rule 70 (postfix -> primary .)
    Not             reduce using rule 70 (postfix -> primary .)
    Integer         reduce using rule 70 (postfix -> primary .)
    LParen          reduce using rule 70 (postfix -> primary .)


state 58

    (97) primary -> Integer .

    Mul             reduce using rule 97 (primary -> Integer .)
    Div             reduce using rule 97 (primary -> Integer .)
    Mod             reduce using rule 97 (primary -> Integer .)
    Plus            reduce using rule 97 (primary -> Integer .)
    Minus           reduce using rule 97 (primary -> Integer .)
    Less            reduce using rule 97 (primary -> Integer .)
    Greater         reduce using rule 97 (primary -> Integer .)
    LessEqual       reduce using rule 97 (primary -> Integer .)
    GreaterEqual    reduce using rule 97 (primary -> Integer .)
    NotEqual        reduce using rule 97 (primary -> Integer .)
    Equal           reduce using rule 97 (primary -> Integer .)
    BitAnd          reduce using rule 97 (primary -> Integer .)
    Xor             reduce using rule 97 (primary -> Integer .)
    BitOr           reduce using rule 97 (primary -> Integer .)
    And             reduce using rule 97 (primary -> Integer .)
    Question        reduce using rule 97 (primary -> Integer .)
    Or              reduce using rule 97 (primary -> Integer .)
    Semi            reduce using rule 97 (primary -> Integer .)
    RParen          reduce using rule 97 (primary -> Integer .)
    Comma           reduce using rule 97 (primary -> Integer .)
    Int             reduce using rule 97 (primary -> Integer .)
    Colon           reduce using rule 97 (primary -> Integer .)
    Identifier      reduce using rule 97 (primary -> Integer .)
    BitNot          reduce using rule 97 (primary -> Integer .)
    Not             reduce using rule 97 (primary -> Integer .)
    Integer         reduce using rule 97 (primary -> Integer .)
    LParen          reduce using rule 97 (primary -> Integer .)


state 59

    (56) declaration -> type Identifier Assign . expression
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 96
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 60

    (6) function -> type Identifier LParen parameter RParen LBrace block . RBrace
    (11) block -> block . block_item
    (13) block_item -> . statement
    (14) block_item -> . declaration Semi
    (15) statement -> . statement_matched
    (16) statement -> . statement_unmatched
    (55) declaration -> . type Identifier
    (56) declaration -> . type Identifier Assign expression
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (4) type -> . Int
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    RBrace          shift and go to state 97
    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Int             shift and go to state 5
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    type                           shift and go to state 12
    block_item                     shift and go to state 26
    statement                      shift and go to state 27
    declaration                    shift and go to state 28
    statement_matched              shift and go to state 29
    statement_unmatched            shift and go to state 30
    expression                     shift and go to state 31
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 61

    (79) assignment -> Identifier Assign . expression
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 98
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 62

    (71) postfix -> Identifier LParen . expression_list RParen
    (72) expression_list -> . expression_list expression_item
    (73) expression_list -> . empty
    (1) empty -> .

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)

    expression_list                shift and go to state 99
    empty                          shift and go to state 100

state 63

    (99) primary -> LParen expression . RParen

    RParen          shift and go to state 101


state 64

    (50) statement_matched -> LBrace block . RBrace
    (11) block -> block . block_item
    (13) block_item -> . statement
    (14) block_item -> . declaration Semi
    (15) statement -> . statement_matched
    (16) statement -> . statement_unmatched
    (55) declaration -> . type Identifier
    (56) declaration -> . type Identifier Assign expression
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (4) type -> . Int
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    RBrace          shift and go to state 102
    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Int             shift and go to state 5
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    block_item                     shift and go to state 26
    statement                      shift and go to state 27
    declaration                    shift and go to state 28
    statement_matched              shift and go to state 29
    statement_unmatched            shift and go to state 30
    type                           shift and go to state 12
    expression                     shift and go to state 31
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 65

    (14) block_item -> declaration Semi .

    RBrace          reduce using rule 14 (block_item -> declaration Semi .)
    If              reduce using rule 14 (block_item -> declaration Semi .)
    While           reduce using rule 14 (block_item -> declaration Semi .)
    Do              reduce using rule 14 (block_item -> declaration Semi .)
    For             reduce using rule 14 (block_item -> declaration Semi .)
    Return          reduce using rule 14 (block_item -> declaration Semi .)
    LBrace          reduce using rule 14 (block_item -> declaration Semi .)
    Break           reduce using rule 14 (block_item -> declaration Semi .)
    Continue        reduce using rule 14 (block_item -> declaration Semi .)
    Int             reduce using rule 14 (block_item -> declaration Semi .)
    Identifier      reduce using rule 14 (block_item -> declaration Semi .)
    Minus           reduce using rule 14 (block_item -> declaration Semi .)
    BitNot          reduce using rule 14 (block_item -> declaration Semi .)
    Not             reduce using rule 14 (block_item -> declaration Semi .)
    Integer         reduce using rule 14 (block_item -> declaration Semi .)
    LParen          reduce using rule 14 (block_item -> declaration Semi .)
    Semi            reduce using rule 14 (block_item -> declaration Semi .)


state 66

    (17) statement_matched -> If LParen . expression RParen statement_matched Else statement_matched
    (18) statement_unmatched -> If LParen . expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> If LParen . expression RParen statement
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 103
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 67

    (20) statement_matched -> While LParen . expression RParen statement_matched
    (21) statement_unmatched -> While LParen . expression RParen statement_unmatched
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 104
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 68

    (22) statement_matched -> Do statement_matched . While expression Semi

    While           shift and go to state 105


state 69

    (23) statement_unmatched -> Do statement_unmatched . While expression Semi

    While           shift and go to state 106


state 70

    (24) statement_matched -> For LParen . expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> For LParen . declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> For LParen . Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> For LParen . expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> For LParen . declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> For LParen . expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> For LParen . declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> For LParen . expression Semi Semi RParen statement_matched
    (39) statement_matched -> For LParen . declaration Semi Semi RParen statement_matched
    (42) statement_matched -> For LParen . Semi expression Semi RParen statement_matched
    (44) statement_matched -> For LParen . Semi Semi expression RParen statement_matched
    (46) statement_matched -> For LParen . Semi Semi RParen statement_matched
    (26) statement_unmatched -> For LParen . expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> For LParen . declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> For LParen . Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> For LParen . expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> For LParen . declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> For LParen . expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> For LParen . declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> For LParen . expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> For LParen . declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> For LParen . Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> For LParen . Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> For LParen . Semi Semi RParen statement_unmatched
    (57) expression -> . assignment
    (55) declaration -> . type Identifier
    (56) declaration -> . type Identifier Assign expression
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (4) type -> . Int
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Semi            shift and go to state 108
    Identifier      shift and go to state 22
    Int             shift and go to state 5
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 107
    declaration                    shift and go to state 109
    assignment                     shift and go to state 41
    type                           shift and go to state 12
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 71

    (48) statement_matched -> Return expression . Semi

    Semi            shift and go to state 110


state 72

    (49) statement_matched -> opt_expression Semi .

    RBrace          reduce using rule 49 (statement_matched -> opt_expression Semi .)
    If              reduce using rule 49 (statement_matched -> opt_expression Semi .)
    While           reduce using rule 49 (statement_matched -> opt_expression Semi .)
    Do              reduce using rule 49 (statement_matched -> opt_expression Semi .)
    For             reduce using rule 49 (statement_matched -> opt_expression Semi .)
    Return          reduce using rule 49 (statement_matched -> opt_expression Semi .)
    LBrace          reduce using rule 49 (statement_matched -> opt_expression Semi .)
    Break           reduce using rule 49 (statement_matched -> opt_expression Semi .)
    Continue        reduce using rule 49 (statement_matched -> opt_expression Semi .)
    Int             reduce using rule 49 (statement_matched -> opt_expression Semi .)
    Identifier      reduce using rule 49 (statement_matched -> opt_expression Semi .)
    Minus           reduce using rule 49 (statement_matched -> opt_expression Semi .)
    BitNot          reduce using rule 49 (statement_matched -> opt_expression Semi .)
    Not             reduce using rule 49 (statement_matched -> opt_expression Semi .)
    Integer         reduce using rule 49 (statement_matched -> opt_expression Semi .)
    LParen          reduce using rule 49 (statement_matched -> opt_expression Semi .)
    Semi            reduce using rule 49 (statement_matched -> opt_expression Semi .)
    Else            reduce using rule 49 (statement_matched -> opt_expression Semi .)


state 73

    (51) statement_matched -> Break Semi .

    RBrace          reduce using rule 51 (statement_matched -> Break Semi .)
    If              reduce using rule 51 (statement_matched -> Break Semi .)
    While           reduce using rule 51 (statement_matched -> Break Semi .)
    Do              reduce using rule 51 (statement_matched -> Break Semi .)
    For             reduce using rule 51 (statement_matched -> Break Semi .)
    Return          reduce using rule 51 (statement_matched -> Break Semi .)
    LBrace          reduce using rule 51 (statement_matched -> Break Semi .)
    Break           reduce using rule 51 (statement_matched -> Break Semi .)
    Continue        reduce using rule 51 (statement_matched -> Break Semi .)
    Int             reduce using rule 51 (statement_matched -> Break Semi .)
    Identifier      reduce using rule 51 (statement_matched -> Break Semi .)
    Minus           reduce using rule 51 (statement_matched -> Break Semi .)
    BitNot          reduce using rule 51 (statement_matched -> Break Semi .)
    Not             reduce using rule 51 (statement_matched -> Break Semi .)
    Integer         reduce using rule 51 (statement_matched -> Break Semi .)
    LParen          reduce using rule 51 (statement_matched -> Break Semi .)
    Semi            reduce using rule 51 (statement_matched -> Break Semi .)
    Else            reduce using rule 51 (statement_matched -> Break Semi .)


state 74

    (52) statement_matched -> Continue Semi .

    RBrace          reduce using rule 52 (statement_matched -> Continue Semi .)
    If              reduce using rule 52 (statement_matched -> Continue Semi .)
    While           reduce using rule 52 (statement_matched -> Continue Semi .)
    Do              reduce using rule 52 (statement_matched -> Continue Semi .)
    For             reduce using rule 52 (statement_matched -> Continue Semi .)
    Return          reduce using rule 52 (statement_matched -> Continue Semi .)
    LBrace          reduce using rule 52 (statement_matched -> Continue Semi .)
    Break           reduce using rule 52 (statement_matched -> Continue Semi .)
    Continue        reduce using rule 52 (statement_matched -> Continue Semi .)
    Int             reduce using rule 52 (statement_matched -> Continue Semi .)
    Identifier      reduce using rule 52 (statement_matched -> Continue Semi .)
    Minus           reduce using rule 52 (statement_matched -> Continue Semi .)
    BitNot          reduce using rule 52 (statement_matched -> Continue Semi .)
    Not             reduce using rule 52 (statement_matched -> Continue Semi .)
    Integer         reduce using rule 52 (statement_matched -> Continue Semi .)
    LParen          reduce using rule 52 (statement_matched -> Continue Semi .)
    Semi            reduce using rule 52 (statement_matched -> Continue Semi .)
    Else            reduce using rule 52 (statement_matched -> Continue Semi .)


state 75

    (96) conditional -> logical_or Question . expression Colon conditional
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    logical_or                     shift and go to state 43
    expression                     shift and go to state 111
    conditional                    shift and go to state 42
    assignment                     shift and go to state 41
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 76

    (80) logical_or -> logical_or Or . logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    logical_and                    shift and go to state 112
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 77

    (81) logical_and -> logical_and And . bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    bit_or                         shift and go to state 113
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 78

    (82) bit_or -> bit_or BitOr . xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    xor                            shift and go to state 114
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 79

    (83) xor -> xor Xor . bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    bit_and                        shift and go to state 115
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 80

    (84) bit_and -> bit_and BitAnd . equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    equality                       shift and go to state 116
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 81

    (85) equality -> equality NotEqual . relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    relational                     shift and go to state 117
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 82

    (86) equality -> equality Equal . relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    relational                     shift and go to state 118
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 83

    (87) relational -> relational Less . additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    additive                       shift and go to state 119
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 84

    (88) relational -> relational Greater . additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    additive                       shift and go to state 120
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 85

    (89) relational -> relational LessEqual . additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    additive                       shift and go to state 121
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 86

    (90) relational -> relational GreaterEqual . additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    additive                       shift and go to state 122
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 87

    (91) additive -> additive Plus . multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    multiplicative                 shift and go to state 123
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 88

    (92) additive -> additive Minus . multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    multiplicative                 shift and go to state 124
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 89

    (93) multiplicative -> multiplicative Mul . unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    unary                          shift and go to state 125
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 90

    (94) multiplicative -> multiplicative Div . unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    unary                          shift and go to state 126
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 91

    (95) multiplicative -> multiplicative Mod . unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    unary                          shift and go to state 127
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 92

    (76) unary -> Minus unary .

    Mul             reduce using rule 76 (unary -> Minus unary .)
    Div             reduce using rule 76 (unary -> Minus unary .)
    Mod             reduce using rule 76 (unary -> Minus unary .)
    Plus            reduce using rule 76 (unary -> Minus unary .)
    Minus           reduce using rule 76 (unary -> Minus unary .)
    Less            reduce using rule 76 (unary -> Minus unary .)
    Greater         reduce using rule 76 (unary -> Minus unary .)
    LessEqual       reduce using rule 76 (unary -> Minus unary .)
    GreaterEqual    reduce using rule 76 (unary -> Minus unary .)
    NotEqual        reduce using rule 76 (unary -> Minus unary .)
    Equal           reduce using rule 76 (unary -> Minus unary .)
    BitAnd          reduce using rule 76 (unary -> Minus unary .)
    Xor             reduce using rule 76 (unary -> Minus unary .)
    BitOr           reduce using rule 76 (unary -> Minus unary .)
    And             reduce using rule 76 (unary -> Minus unary .)
    Question        reduce using rule 76 (unary -> Minus unary .)
    Or              reduce using rule 76 (unary -> Minus unary .)
    Semi            reduce using rule 76 (unary -> Minus unary .)
    RParen          reduce using rule 76 (unary -> Minus unary .)
    Comma           reduce using rule 76 (unary -> Minus unary .)
    Int             reduce using rule 76 (unary -> Minus unary .)
    Colon           reduce using rule 76 (unary -> Minus unary .)
    Identifier      reduce using rule 76 (unary -> Minus unary .)
    BitNot          reduce using rule 76 (unary -> Minus unary .)
    Not             reduce using rule 76 (unary -> Minus unary .)
    Integer         reduce using rule 76 (unary -> Minus unary .)
    LParen          reduce using rule 76 (unary -> Minus unary .)


state 93

    (71) postfix -> Identifier . LParen expression_list RParen
    (98) primary -> Identifier .

  ! shift/reduce conflict for LParen resolved as shift
    LParen          shift and go to state 62
    Mul             reduce using rule 98 (primary -> Identifier .)
    Div             reduce using rule 98 (primary -> Identifier .)
    Mod             reduce using rule 98 (primary -> Identifier .)
    Plus            reduce using rule 98 (primary -> Identifier .)
    Minus           reduce using rule 98 (primary -> Identifier .)
    Less            reduce using rule 98 (primary -> Identifier .)
    Greater         reduce using rule 98 (primary -> Identifier .)
    LessEqual       reduce using rule 98 (primary -> Identifier .)
    GreaterEqual    reduce using rule 98 (primary -> Identifier .)
    NotEqual        reduce using rule 98 (primary -> Identifier .)
    Equal           reduce using rule 98 (primary -> Identifier .)
    BitAnd          reduce using rule 98 (primary -> Identifier .)
    Xor             reduce using rule 98 (primary -> Identifier .)
    BitOr           reduce using rule 98 (primary -> Identifier .)
    And             reduce using rule 98 (primary -> Identifier .)
    Question        reduce using rule 98 (primary -> Identifier .)
    Or              reduce using rule 98 (primary -> Identifier .)
    Semi            reduce using rule 98 (primary -> Identifier .)
    RParen          reduce using rule 98 (primary -> Identifier .)
    Comma           reduce using rule 98 (primary -> Identifier .)
    Int             reduce using rule 98 (primary -> Identifier .)
    Colon           reduce using rule 98 (primary -> Identifier .)
    Identifier      reduce using rule 98 (primary -> Identifier .)
    BitNot          reduce using rule 98 (primary -> Identifier .)
    Not             reduce using rule 98 (primary -> Identifier .)
    Integer         reduce using rule 98 (primary -> Identifier .)

  ! LParen          [ reduce using rule 98 (primary -> Identifier .) ]


state 94

    (77) unary -> BitNot unary .

    Mul             reduce using rule 77 (unary -> BitNot unary .)
    Div             reduce using rule 77 (unary -> BitNot unary .)
    Mod             reduce using rule 77 (unary -> BitNot unary .)
    Plus            reduce using rule 77 (unary -> BitNot unary .)
    Minus           reduce using rule 77 (unary -> BitNot unary .)
    Less            reduce using rule 77 (unary -> BitNot unary .)
    Greater         reduce using rule 77 (unary -> BitNot unary .)
    LessEqual       reduce using rule 77 (unary -> BitNot unary .)
    GreaterEqual    reduce using rule 77 (unary -> BitNot unary .)
    NotEqual        reduce using rule 77 (unary -> BitNot unary .)
    Equal           reduce using rule 77 (unary -> BitNot unary .)
    BitAnd          reduce using rule 77 (unary -> BitNot unary .)
    Xor             reduce using rule 77 (unary -> BitNot unary .)
    BitOr           reduce using rule 77 (unary -> BitNot unary .)
    And             reduce using rule 77 (unary -> BitNot unary .)
    Question        reduce using rule 77 (unary -> BitNot unary .)
    Or              reduce using rule 77 (unary -> BitNot unary .)
    Semi            reduce using rule 77 (unary -> BitNot unary .)
    RParen          reduce using rule 77 (unary -> BitNot unary .)
    Comma           reduce using rule 77 (unary -> BitNot unary .)
    Int             reduce using rule 77 (unary -> BitNot unary .)
    Colon           reduce using rule 77 (unary -> BitNot unary .)
    Identifier      reduce using rule 77 (unary -> BitNot unary .)
    BitNot          reduce using rule 77 (unary -> BitNot unary .)
    Not             reduce using rule 77 (unary -> BitNot unary .)
    Integer         reduce using rule 77 (unary -> BitNot unary .)
    LParen          reduce using rule 77 (unary -> BitNot unary .)


state 95

    (78) unary -> Not unary .

    Mul             reduce using rule 78 (unary -> Not unary .)
    Div             reduce using rule 78 (unary -> Not unary .)
    Mod             reduce using rule 78 (unary -> Not unary .)
    Plus            reduce using rule 78 (unary -> Not unary .)
    Minus           reduce using rule 78 (unary -> Not unary .)
    Less            reduce using rule 78 (unary -> Not unary .)
    Greater         reduce using rule 78 (unary -> Not unary .)
    LessEqual       reduce using rule 78 (unary -> Not unary .)
    GreaterEqual    reduce using rule 78 (unary -> Not unary .)
    NotEqual        reduce using rule 78 (unary -> Not unary .)
    Equal           reduce using rule 78 (unary -> Not unary .)
    BitAnd          reduce using rule 78 (unary -> Not unary .)
    Xor             reduce using rule 78 (unary -> Not unary .)
    BitOr           reduce using rule 78 (unary -> Not unary .)
    And             reduce using rule 78 (unary -> Not unary .)
    Question        reduce using rule 78 (unary -> Not unary .)
    Or              reduce using rule 78 (unary -> Not unary .)
    Semi            reduce using rule 78 (unary -> Not unary .)
    RParen          reduce using rule 78 (unary -> Not unary .)
    Comma           reduce using rule 78 (unary -> Not unary .)
    Int             reduce using rule 78 (unary -> Not unary .)
    Colon           reduce using rule 78 (unary -> Not unary .)
    Identifier      reduce using rule 78 (unary -> Not unary .)
    BitNot          reduce using rule 78 (unary -> Not unary .)
    Not             reduce using rule 78 (unary -> Not unary .)
    Integer         reduce using rule 78 (unary -> Not unary .)
    LParen          reduce using rule 78 (unary -> Not unary .)


state 96

    (56) declaration -> type Identifier Assign expression .

    RParen          reduce using rule 56 (declaration -> type Identifier Assign expression .)
    Comma           reduce using rule 56 (declaration -> type Identifier Assign expression .)
    Int             reduce using rule 56 (declaration -> type Identifier Assign expression .)
    Semi            reduce using rule 56 (declaration -> type Identifier Assign expression .)


state 97

    (6) function -> type Identifier LParen parameter RParen LBrace block RBrace .

    Int             reduce using rule 6 (function -> type Identifier LParen parameter RParen LBrace block RBrace .)
    $end            reduce using rule 6 (function -> type Identifier LParen parameter RParen LBrace block RBrace .)


state 98

    (79) assignment -> Identifier Assign expression .

    Semi            reduce using rule 79 (assignment -> Identifier Assign expression .)
    RParen          reduce using rule 79 (assignment -> Identifier Assign expression .)
    Comma           reduce using rule 79 (assignment -> Identifier Assign expression .)
    Int             reduce using rule 79 (assignment -> Identifier Assign expression .)
    Colon           reduce using rule 79 (assignment -> Identifier Assign expression .)
    Identifier      reduce using rule 79 (assignment -> Identifier Assign expression .)
    Minus           reduce using rule 79 (assignment -> Identifier Assign expression .)
    BitNot          reduce using rule 79 (assignment -> Identifier Assign expression .)
    Not             reduce using rule 79 (assignment -> Identifier Assign expression .)
    Integer         reduce using rule 79 (assignment -> Identifier Assign expression .)
    LParen          reduce using rule 79 (assignment -> Identifier Assign expression .)


state 99

    (71) postfix -> Identifier LParen expression_list . RParen
    (72) expression_list -> expression_list . expression_item
    (74) expression_item -> . Comma expression
    (75) expression_item -> . expression
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    RParen          shift and go to state 128
    Comma           shift and go to state 130
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression_item                shift and go to state 129
    expression                     shift and go to state 131
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 100

    (73) expression_list -> empty .

    RParen          reduce using rule 73 (expression_list -> empty .)
    Comma           reduce using rule 73 (expression_list -> empty .)
    Identifier      reduce using rule 73 (expression_list -> empty .)
    Minus           reduce using rule 73 (expression_list -> empty .)
    BitNot          reduce using rule 73 (expression_list -> empty .)
    Not             reduce using rule 73 (expression_list -> empty .)
    Integer         reduce using rule 73 (expression_list -> empty .)
    LParen          reduce using rule 73 (expression_list -> empty .)


state 101

    (99) primary -> LParen expression RParen .

    Mul             reduce using rule 99 (primary -> LParen expression RParen .)
    Div             reduce using rule 99 (primary -> LParen expression RParen .)
    Mod             reduce using rule 99 (primary -> LParen expression RParen .)
    Plus            reduce using rule 99 (primary -> LParen expression RParen .)
    Minus           reduce using rule 99 (primary -> LParen expression RParen .)
    Less            reduce using rule 99 (primary -> LParen expression RParen .)
    Greater         reduce using rule 99 (primary -> LParen expression RParen .)
    LessEqual       reduce using rule 99 (primary -> LParen expression RParen .)
    GreaterEqual    reduce using rule 99 (primary -> LParen expression RParen .)
    NotEqual        reduce using rule 99 (primary -> LParen expression RParen .)
    Equal           reduce using rule 99 (primary -> LParen expression RParen .)
    BitAnd          reduce using rule 99 (primary -> LParen expression RParen .)
    Xor             reduce using rule 99 (primary -> LParen expression RParen .)
    BitOr           reduce using rule 99 (primary -> LParen expression RParen .)
    And             reduce using rule 99 (primary -> LParen expression RParen .)
    Question        reduce using rule 99 (primary -> LParen expression RParen .)
    Or              reduce using rule 99 (primary -> LParen expression RParen .)
    Semi            reduce using rule 99 (primary -> LParen expression RParen .)
    RParen          reduce using rule 99 (primary -> LParen expression RParen .)
    Comma           reduce using rule 99 (primary -> LParen expression RParen .)
    Int             reduce using rule 99 (primary -> LParen expression RParen .)
    Colon           reduce using rule 99 (primary -> LParen expression RParen .)
    Identifier      reduce using rule 99 (primary -> LParen expression RParen .)
    BitNot          reduce using rule 99 (primary -> LParen expression RParen .)
    Not             reduce using rule 99 (primary -> LParen expression RParen .)
    Integer         reduce using rule 99 (primary -> LParen expression RParen .)
    LParen          reduce using rule 99 (primary -> LParen expression RParen .)


state 102

    (50) statement_matched -> LBrace block RBrace .

    RBrace          reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    If              reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    While           reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    Do              reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    For             reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    Return          reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    LBrace          reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    Break           reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    Continue        reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    Int             reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    Identifier      reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    Minus           reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    BitNot          reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    Not             reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    Integer         reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    LParen          reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    Semi            reduce using rule 50 (statement_matched -> LBrace block RBrace .)
    Else            reduce using rule 50 (statement_matched -> LBrace block RBrace .)


state 103

    (17) statement_matched -> If LParen expression . RParen statement_matched Else statement_matched
    (18) statement_unmatched -> If LParen expression . RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> If LParen expression . RParen statement

    RParen          shift and go to state 132


state 104

    (20) statement_matched -> While LParen expression . RParen statement_matched
    (21) statement_unmatched -> While LParen expression . RParen statement_unmatched

    RParen          shift and go to state 133


state 105

    (22) statement_matched -> Do statement_matched While . expression Semi
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 134
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 106

    (23) statement_unmatched -> Do statement_unmatched While . expression Semi
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 135
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 107

    (24) statement_matched -> For LParen expression . Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> For LParen expression . Semi Semi expression RParen statement_matched
    (34) statement_matched -> For LParen expression . Semi expression Semi RParen statement_matched
    (38) statement_matched -> For LParen expression . Semi Semi RParen statement_matched
    (26) statement_unmatched -> For LParen expression . Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> For LParen expression . Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> For LParen expression . Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> For LParen expression . Semi Semi RParen statement_unmatched

    Semi            shift and go to state 136


state 108

    (28) statement_matched -> For LParen Semi . expression Semi expression RParen statement_matched
    (42) statement_matched -> For LParen Semi . expression Semi RParen statement_matched
    (44) statement_matched -> For LParen Semi . Semi expression RParen statement_matched
    (46) statement_matched -> For LParen Semi . Semi RParen statement_matched
    (29) statement_unmatched -> For LParen Semi . expression Semi expression RParen statement_unmatched
    (43) statement_unmatched -> For LParen Semi . expression Semi RParen statement_unmatched
    (45) statement_unmatched -> For LParen Semi . Semi expression RParen statement_unmatched
    (47) statement_unmatched -> For LParen Semi . Semi RParen statement_unmatched
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Semi            shift and go to state 137
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 138
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 109

    (25) statement_matched -> For LParen declaration . Semi expression Semi expression RParen statement_matched
    (31) statement_matched -> For LParen declaration . Semi Semi expression RParen statement_matched
    (35) statement_matched -> For LParen declaration . Semi expression Semi RParen statement_matched
    (39) statement_matched -> For LParen declaration . Semi Semi RParen statement_matched
    (27) statement_unmatched -> For LParen declaration . Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> For LParen declaration . Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> For LParen declaration . Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> For LParen declaration . Semi Semi RParen statement_unmatched

    Semi            shift and go to state 139


state 110

    (48) statement_matched -> Return expression Semi .

    RBrace          reduce using rule 48 (statement_matched -> Return expression Semi .)
    If              reduce using rule 48 (statement_matched -> Return expression Semi .)
    While           reduce using rule 48 (statement_matched -> Return expression Semi .)
    Do              reduce using rule 48 (statement_matched -> Return expression Semi .)
    For             reduce using rule 48 (statement_matched -> Return expression Semi .)
    Return          reduce using rule 48 (statement_matched -> Return expression Semi .)
    LBrace          reduce using rule 48 (statement_matched -> Return expression Semi .)
    Break           reduce using rule 48 (statement_matched -> Return expression Semi .)
    Continue        reduce using rule 48 (statement_matched -> Return expression Semi .)
    Int             reduce using rule 48 (statement_matched -> Return expression Semi .)
    Identifier      reduce using rule 48 (statement_matched -> Return expression Semi .)
    Minus           reduce using rule 48 (statement_matched -> Return expression Semi .)
    BitNot          reduce using rule 48 (statement_matched -> Return expression Semi .)
    Not             reduce using rule 48 (statement_matched -> Return expression Semi .)
    Integer         reduce using rule 48 (statement_matched -> Return expression Semi .)
    LParen          reduce using rule 48 (statement_matched -> Return expression Semi .)
    Semi            reduce using rule 48 (statement_matched -> Return expression Semi .)
    Else            reduce using rule 48 (statement_matched -> Return expression Semi .)


state 111

    (96) conditional -> logical_or Question expression . Colon conditional

    Colon           shift and go to state 140


state 112

    (80) logical_or -> logical_or Or logical_and .
    (81) logical_and -> logical_and . And bit_or

    Question        reduce using rule 80 (logical_or -> logical_or Or logical_and .)
    Or              reduce using rule 80 (logical_or -> logical_or Or logical_and .)
    Semi            reduce using rule 80 (logical_or -> logical_or Or logical_and .)
    RParen          reduce using rule 80 (logical_or -> logical_or Or logical_and .)
    Comma           reduce using rule 80 (logical_or -> logical_or Or logical_and .)
    Int             reduce using rule 80 (logical_or -> logical_or Or logical_and .)
    Colon           reduce using rule 80 (logical_or -> logical_or Or logical_and .)
    Identifier      reduce using rule 80 (logical_or -> logical_or Or logical_and .)
    Minus           reduce using rule 80 (logical_or -> logical_or Or logical_and .)
    BitNot          reduce using rule 80 (logical_or -> logical_or Or logical_and .)
    Not             reduce using rule 80 (logical_or -> logical_or Or logical_and .)
    Integer         reduce using rule 80 (logical_or -> logical_or Or logical_and .)
    LParen          reduce using rule 80 (logical_or -> logical_or Or logical_and .)
    And             shift and go to state 77


state 113

    (81) logical_and -> logical_and And bit_or .
    (82) bit_or -> bit_or . BitOr xor

    And             reduce using rule 81 (logical_and -> logical_and And bit_or .)
    Question        reduce using rule 81 (logical_and -> logical_and And bit_or .)
    Or              reduce using rule 81 (logical_and -> logical_and And bit_or .)
    Semi            reduce using rule 81 (logical_and -> logical_and And bit_or .)
    RParen          reduce using rule 81 (logical_and -> logical_and And bit_or .)
    Comma           reduce using rule 81 (logical_and -> logical_and And bit_or .)
    Int             reduce using rule 81 (logical_and -> logical_and And bit_or .)
    Colon           reduce using rule 81 (logical_and -> logical_and And bit_or .)
    Identifier      reduce using rule 81 (logical_and -> logical_and And bit_or .)
    Minus           reduce using rule 81 (logical_and -> logical_and And bit_or .)
    BitNot          reduce using rule 81 (logical_and -> logical_and And bit_or .)
    Not             reduce using rule 81 (logical_and -> logical_and And bit_or .)
    Integer         reduce using rule 81 (logical_and -> logical_and And bit_or .)
    LParen          reduce using rule 81 (logical_and -> logical_and And bit_or .)
    BitOr           shift and go to state 78


state 114

    (82) bit_or -> bit_or BitOr xor .
    (83) xor -> xor . Xor bit_and

    BitOr           reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    And             reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    Question        reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    Or              reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    Semi            reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    RParen          reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    Comma           reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    Int             reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    Colon           reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    Identifier      reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    Minus           reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    BitNot          reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    Not             reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    Integer         reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    LParen          reduce using rule 82 (bit_or -> bit_or BitOr xor .)
    Xor             shift and go to state 79


state 115

    (83) xor -> xor Xor bit_and .
    (84) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 83 (xor -> xor Xor bit_and .)
    BitOr           reduce using rule 83 (xor -> xor Xor bit_and .)
    And             reduce using rule 83 (xor -> xor Xor bit_and .)
    Question        reduce using rule 83 (xor -> xor Xor bit_and .)
    Or              reduce using rule 83 (xor -> xor Xor bit_and .)
    Semi            reduce using rule 83 (xor -> xor Xor bit_and .)
    RParen          reduce using rule 83 (xor -> xor Xor bit_and .)
    Comma           reduce using rule 83 (xor -> xor Xor bit_and .)
    Int             reduce using rule 83 (xor -> xor Xor bit_and .)
    Colon           reduce using rule 83 (xor -> xor Xor bit_and .)
    Identifier      reduce using rule 83 (xor -> xor Xor bit_and .)
    Minus           reduce using rule 83 (xor -> xor Xor bit_and .)
    BitNot          reduce using rule 83 (xor -> xor Xor bit_and .)
    Not             reduce using rule 83 (xor -> xor Xor bit_and .)
    Integer         reduce using rule 83 (xor -> xor Xor bit_and .)
    LParen          reduce using rule 83 (xor -> xor Xor bit_and .)
    BitAnd          shift and go to state 80


state 116

    (84) bit_and -> bit_and BitAnd equality .
    (85) equality -> equality . NotEqual relational
    (86) equality -> equality . Equal relational

    BitAnd          reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    Xor             reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    BitOr           reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    And             reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    Question        reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    Or              reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    Semi            reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    RParen          reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    Comma           reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    Int             reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    Colon           reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    Identifier      reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    Minus           reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    BitNot          reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    Not             reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    Integer         reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    LParen          reduce using rule 84 (bit_and -> bit_and BitAnd equality .)
    NotEqual        shift and go to state 81
    Equal           shift and go to state 82


state 117

    (85) equality -> equality NotEqual relational .
    (87) relational -> relational . Less additive
    (88) relational -> relational . Greater additive
    (89) relational -> relational . LessEqual additive
    (90) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 85 (equality -> equality NotEqual relational .)
    Equal           reduce using rule 85 (equality -> equality NotEqual relational .)
    BitAnd          reduce using rule 85 (equality -> equality NotEqual relational .)
    Xor             reduce using rule 85 (equality -> equality NotEqual relational .)
    BitOr           reduce using rule 85 (equality -> equality NotEqual relational .)
    And             reduce using rule 85 (equality -> equality NotEqual relational .)
    Question        reduce using rule 85 (equality -> equality NotEqual relational .)
    Or              reduce using rule 85 (equality -> equality NotEqual relational .)
    Semi            reduce using rule 85 (equality -> equality NotEqual relational .)
    RParen          reduce using rule 85 (equality -> equality NotEqual relational .)
    Comma           reduce using rule 85 (equality -> equality NotEqual relational .)
    Int             reduce using rule 85 (equality -> equality NotEqual relational .)
    Colon           reduce using rule 85 (equality -> equality NotEqual relational .)
    Identifier      reduce using rule 85 (equality -> equality NotEqual relational .)
    Minus           reduce using rule 85 (equality -> equality NotEqual relational .)
    BitNot          reduce using rule 85 (equality -> equality NotEqual relational .)
    Not             reduce using rule 85 (equality -> equality NotEqual relational .)
    Integer         reduce using rule 85 (equality -> equality NotEqual relational .)
    LParen          reduce using rule 85 (equality -> equality NotEqual relational .)
    Less            shift and go to state 83
    Greater         shift and go to state 84
    LessEqual       shift and go to state 85
    GreaterEqual    shift and go to state 86


state 118

    (86) equality -> equality Equal relational .
    (87) relational -> relational . Less additive
    (88) relational -> relational . Greater additive
    (89) relational -> relational . LessEqual additive
    (90) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 86 (equality -> equality Equal relational .)
    Equal           reduce using rule 86 (equality -> equality Equal relational .)
    BitAnd          reduce using rule 86 (equality -> equality Equal relational .)
    Xor             reduce using rule 86 (equality -> equality Equal relational .)
    BitOr           reduce using rule 86 (equality -> equality Equal relational .)
    And             reduce using rule 86 (equality -> equality Equal relational .)
    Question        reduce using rule 86 (equality -> equality Equal relational .)
    Or              reduce using rule 86 (equality -> equality Equal relational .)
    Semi            reduce using rule 86 (equality -> equality Equal relational .)
    RParen          reduce using rule 86 (equality -> equality Equal relational .)
    Comma           reduce using rule 86 (equality -> equality Equal relational .)
    Int             reduce using rule 86 (equality -> equality Equal relational .)
    Colon           reduce using rule 86 (equality -> equality Equal relational .)
    Identifier      reduce using rule 86 (equality -> equality Equal relational .)
    Minus           reduce using rule 86 (equality -> equality Equal relational .)
    BitNot          reduce using rule 86 (equality -> equality Equal relational .)
    Not             reduce using rule 86 (equality -> equality Equal relational .)
    Integer         reduce using rule 86 (equality -> equality Equal relational .)
    LParen          reduce using rule 86 (equality -> equality Equal relational .)
    Less            shift and go to state 83
    Greater         shift and go to state 84
    LessEqual       shift and go to state 85
    GreaterEqual    shift and go to state 86


state 119

    (87) relational -> relational Less additive .
    (91) additive -> additive . Plus multiplicative
    (92) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 87 (relational -> relational Less additive .)
    Greater         reduce using rule 87 (relational -> relational Less additive .)
    LessEqual       reduce using rule 87 (relational -> relational Less additive .)
    GreaterEqual    reduce using rule 87 (relational -> relational Less additive .)
    NotEqual        reduce using rule 87 (relational -> relational Less additive .)
    Equal           reduce using rule 87 (relational -> relational Less additive .)
    BitAnd          reduce using rule 87 (relational -> relational Less additive .)
    Xor             reduce using rule 87 (relational -> relational Less additive .)
    BitOr           reduce using rule 87 (relational -> relational Less additive .)
    And             reduce using rule 87 (relational -> relational Less additive .)
    Question        reduce using rule 87 (relational -> relational Less additive .)
    Or              reduce using rule 87 (relational -> relational Less additive .)
    Semi            reduce using rule 87 (relational -> relational Less additive .)
    RParen          reduce using rule 87 (relational -> relational Less additive .)
    Comma           reduce using rule 87 (relational -> relational Less additive .)
    Int             reduce using rule 87 (relational -> relational Less additive .)
    Colon           reduce using rule 87 (relational -> relational Less additive .)
    Identifier      reduce using rule 87 (relational -> relational Less additive .)
    BitNot          reduce using rule 87 (relational -> relational Less additive .)
    Not             reduce using rule 87 (relational -> relational Less additive .)
    Integer         reduce using rule 87 (relational -> relational Less additive .)
    LParen          reduce using rule 87 (relational -> relational Less additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88

  ! Minus           [ reduce using rule 87 (relational -> relational Less additive .) ]


state 120

    (88) relational -> relational Greater additive .
    (91) additive -> additive . Plus multiplicative
    (92) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 88 (relational -> relational Greater additive .)
    Greater         reduce using rule 88 (relational -> relational Greater additive .)
    LessEqual       reduce using rule 88 (relational -> relational Greater additive .)
    GreaterEqual    reduce using rule 88 (relational -> relational Greater additive .)
    NotEqual        reduce using rule 88 (relational -> relational Greater additive .)
    Equal           reduce using rule 88 (relational -> relational Greater additive .)
    BitAnd          reduce using rule 88 (relational -> relational Greater additive .)
    Xor             reduce using rule 88 (relational -> relational Greater additive .)
    BitOr           reduce using rule 88 (relational -> relational Greater additive .)
    And             reduce using rule 88 (relational -> relational Greater additive .)
    Question        reduce using rule 88 (relational -> relational Greater additive .)
    Or              reduce using rule 88 (relational -> relational Greater additive .)
    Semi            reduce using rule 88 (relational -> relational Greater additive .)
    RParen          reduce using rule 88 (relational -> relational Greater additive .)
    Comma           reduce using rule 88 (relational -> relational Greater additive .)
    Int             reduce using rule 88 (relational -> relational Greater additive .)
    Colon           reduce using rule 88 (relational -> relational Greater additive .)
    Identifier      reduce using rule 88 (relational -> relational Greater additive .)
    BitNot          reduce using rule 88 (relational -> relational Greater additive .)
    Not             reduce using rule 88 (relational -> relational Greater additive .)
    Integer         reduce using rule 88 (relational -> relational Greater additive .)
    LParen          reduce using rule 88 (relational -> relational Greater additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88

  ! Minus           [ reduce using rule 88 (relational -> relational Greater additive .) ]


state 121

    (89) relational -> relational LessEqual additive .
    (91) additive -> additive . Plus multiplicative
    (92) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 89 (relational -> relational LessEqual additive .)
    Greater         reduce using rule 89 (relational -> relational LessEqual additive .)
    LessEqual       reduce using rule 89 (relational -> relational LessEqual additive .)
    GreaterEqual    reduce using rule 89 (relational -> relational LessEqual additive .)
    NotEqual        reduce using rule 89 (relational -> relational LessEqual additive .)
    Equal           reduce using rule 89 (relational -> relational LessEqual additive .)
    BitAnd          reduce using rule 89 (relational -> relational LessEqual additive .)
    Xor             reduce using rule 89 (relational -> relational LessEqual additive .)
    BitOr           reduce using rule 89 (relational -> relational LessEqual additive .)
    And             reduce using rule 89 (relational -> relational LessEqual additive .)
    Question        reduce using rule 89 (relational -> relational LessEqual additive .)
    Or              reduce using rule 89 (relational -> relational LessEqual additive .)
    Semi            reduce using rule 89 (relational -> relational LessEqual additive .)
    RParen          reduce using rule 89 (relational -> relational LessEqual additive .)
    Comma           reduce using rule 89 (relational -> relational LessEqual additive .)
    Int             reduce using rule 89 (relational -> relational LessEqual additive .)
    Colon           reduce using rule 89 (relational -> relational LessEqual additive .)
    Identifier      reduce using rule 89 (relational -> relational LessEqual additive .)
    BitNot          reduce using rule 89 (relational -> relational LessEqual additive .)
    Not             reduce using rule 89 (relational -> relational LessEqual additive .)
    Integer         reduce using rule 89 (relational -> relational LessEqual additive .)
    LParen          reduce using rule 89 (relational -> relational LessEqual additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88

  ! Minus           [ reduce using rule 89 (relational -> relational LessEqual additive .) ]


state 122

    (90) relational -> relational GreaterEqual additive .
    (91) additive -> additive . Plus multiplicative
    (92) additive -> additive . Minus multiplicative

  ! shift/reduce conflict for Minus resolved as shift
    Less            reduce using rule 90 (relational -> relational GreaterEqual additive .)
    Greater         reduce using rule 90 (relational -> relational GreaterEqual additive .)
    LessEqual       reduce using rule 90 (relational -> relational GreaterEqual additive .)
    GreaterEqual    reduce using rule 90 (relational -> relational GreaterEqual additive .)
    NotEqual        reduce using rule 90 (relational -> relational GreaterEqual additive .)
    Equal           reduce using rule 90 (relational -> relational GreaterEqual additive .)
    BitAnd          reduce using rule 90 (relational -> relational GreaterEqual additive .)
    Xor             reduce using rule 90 (relational -> relational GreaterEqual additive .)
    BitOr           reduce using rule 90 (relational -> relational GreaterEqual additive .)
    And             reduce using rule 90 (relational -> relational GreaterEqual additive .)
    Question        reduce using rule 90 (relational -> relational GreaterEqual additive .)
    Or              reduce using rule 90 (relational -> relational GreaterEqual additive .)
    Semi            reduce using rule 90 (relational -> relational GreaterEqual additive .)
    RParen          reduce using rule 90 (relational -> relational GreaterEqual additive .)
    Comma           reduce using rule 90 (relational -> relational GreaterEqual additive .)
    Int             reduce using rule 90 (relational -> relational GreaterEqual additive .)
    Colon           reduce using rule 90 (relational -> relational GreaterEqual additive .)
    Identifier      reduce using rule 90 (relational -> relational GreaterEqual additive .)
    BitNot          reduce using rule 90 (relational -> relational GreaterEqual additive .)
    Not             reduce using rule 90 (relational -> relational GreaterEqual additive .)
    Integer         reduce using rule 90 (relational -> relational GreaterEqual additive .)
    LParen          reduce using rule 90 (relational -> relational GreaterEqual additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88

  ! Minus           [ reduce using rule 90 (relational -> relational GreaterEqual additive .) ]


state 123

    (91) additive -> additive Plus multiplicative .
    (93) multiplicative -> multiplicative . Mul unary
    (94) multiplicative -> multiplicative . Div unary
    (95) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 91 (additive -> additive Plus multiplicative .)
    Minus           reduce using rule 91 (additive -> additive Plus multiplicative .)
    Less            reduce using rule 91 (additive -> additive Plus multiplicative .)
    Greater         reduce using rule 91 (additive -> additive Plus multiplicative .)
    LessEqual       reduce using rule 91 (additive -> additive Plus multiplicative .)
    GreaterEqual    reduce using rule 91 (additive -> additive Plus multiplicative .)
    NotEqual        reduce using rule 91 (additive -> additive Plus multiplicative .)
    Equal           reduce using rule 91 (additive -> additive Plus multiplicative .)
    BitAnd          reduce using rule 91 (additive -> additive Plus multiplicative .)
    Xor             reduce using rule 91 (additive -> additive Plus multiplicative .)
    BitOr           reduce using rule 91 (additive -> additive Plus multiplicative .)
    And             reduce using rule 91 (additive -> additive Plus multiplicative .)
    Question        reduce using rule 91 (additive -> additive Plus multiplicative .)
    Or              reduce using rule 91 (additive -> additive Plus multiplicative .)
    Semi            reduce using rule 91 (additive -> additive Plus multiplicative .)
    RParen          reduce using rule 91 (additive -> additive Plus multiplicative .)
    Comma           reduce using rule 91 (additive -> additive Plus multiplicative .)
    Int             reduce using rule 91 (additive -> additive Plus multiplicative .)
    Colon           reduce using rule 91 (additive -> additive Plus multiplicative .)
    Identifier      reduce using rule 91 (additive -> additive Plus multiplicative .)
    BitNot          reduce using rule 91 (additive -> additive Plus multiplicative .)
    Not             reduce using rule 91 (additive -> additive Plus multiplicative .)
    Integer         reduce using rule 91 (additive -> additive Plus multiplicative .)
    LParen          reduce using rule 91 (additive -> additive Plus multiplicative .)
    Mul             shift and go to state 89
    Div             shift and go to state 90
    Mod             shift and go to state 91


state 124

    (92) additive -> additive Minus multiplicative .
    (93) multiplicative -> multiplicative . Mul unary
    (94) multiplicative -> multiplicative . Div unary
    (95) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 92 (additive -> additive Minus multiplicative .)
    Minus           reduce using rule 92 (additive -> additive Minus multiplicative .)
    Less            reduce using rule 92 (additive -> additive Minus multiplicative .)
    Greater         reduce using rule 92 (additive -> additive Minus multiplicative .)
    LessEqual       reduce using rule 92 (additive -> additive Minus multiplicative .)
    GreaterEqual    reduce using rule 92 (additive -> additive Minus multiplicative .)
    NotEqual        reduce using rule 92 (additive -> additive Minus multiplicative .)
    Equal           reduce using rule 92 (additive -> additive Minus multiplicative .)
    BitAnd          reduce using rule 92 (additive -> additive Minus multiplicative .)
    Xor             reduce using rule 92 (additive -> additive Minus multiplicative .)
    BitOr           reduce using rule 92 (additive -> additive Minus multiplicative .)
    And             reduce using rule 92 (additive -> additive Minus multiplicative .)
    Question        reduce using rule 92 (additive -> additive Minus multiplicative .)
    Or              reduce using rule 92 (additive -> additive Minus multiplicative .)
    Semi            reduce using rule 92 (additive -> additive Minus multiplicative .)
    RParen          reduce using rule 92 (additive -> additive Minus multiplicative .)
    Comma           reduce using rule 92 (additive -> additive Minus multiplicative .)
    Int             reduce using rule 92 (additive -> additive Minus multiplicative .)
    Colon           reduce using rule 92 (additive -> additive Minus multiplicative .)
    Identifier      reduce using rule 92 (additive -> additive Minus multiplicative .)
    BitNot          reduce using rule 92 (additive -> additive Minus multiplicative .)
    Not             reduce using rule 92 (additive -> additive Minus multiplicative .)
    Integer         reduce using rule 92 (additive -> additive Minus multiplicative .)
    LParen          reduce using rule 92 (additive -> additive Minus multiplicative .)
    Mul             shift and go to state 89
    Div             shift and go to state 90
    Mod             shift and go to state 91


state 125

    (93) multiplicative -> multiplicative Mul unary .

    Mul             reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Div             reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Mod             reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Plus            reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Minus           reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Less            reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Greater         reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    LessEqual       reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    GreaterEqual    reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    NotEqual        reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Equal           reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    BitAnd          reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Xor             reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    BitOr           reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    And             reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Question        reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Or              reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Semi            reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    RParen          reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Comma           reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Int             reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Colon           reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Identifier      reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    BitNot          reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Not             reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    Integer         reduce using rule 93 (multiplicative -> multiplicative Mul unary .)
    LParen          reduce using rule 93 (multiplicative -> multiplicative Mul unary .)


state 126

    (94) multiplicative -> multiplicative Div unary .

    Mul             reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Div             reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Mod             reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Plus            reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Minus           reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Less            reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Greater         reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    LessEqual       reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    GreaterEqual    reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    NotEqual        reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Equal           reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    BitAnd          reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Xor             reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    BitOr           reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    And             reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Question        reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Or              reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Semi            reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    RParen          reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Comma           reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Int             reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Colon           reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Identifier      reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    BitNot          reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Not             reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    Integer         reduce using rule 94 (multiplicative -> multiplicative Div unary .)
    LParen          reduce using rule 94 (multiplicative -> multiplicative Div unary .)


state 127

    (95) multiplicative -> multiplicative Mod unary .

    Mul             reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Div             reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Mod             reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Plus            reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Minus           reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Less            reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Greater         reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    LessEqual       reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    GreaterEqual    reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    NotEqual        reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Equal           reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    BitAnd          reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Xor             reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    BitOr           reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    And             reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Question        reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Or              reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Semi            reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    RParen          reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Comma           reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Int             reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Colon           reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Identifier      reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    BitNot          reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Not             reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    Integer         reduce using rule 95 (multiplicative -> multiplicative Mod unary .)
    LParen          reduce using rule 95 (multiplicative -> multiplicative Mod unary .)


state 128

    (71) postfix -> Identifier LParen expression_list RParen .

    Mul             reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Div             reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Mod             reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Plus            reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Minus           reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Less            reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Greater         reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    LessEqual       reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    GreaterEqual    reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    NotEqual        reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Equal           reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    BitAnd          reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Xor             reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    BitOr           reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    And             reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Question        reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Or              reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Semi            reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    RParen          reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Comma           reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Int             reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Colon           reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Identifier      reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    BitNot          reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Not             reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    Integer         reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)
    LParen          reduce using rule 71 (postfix -> Identifier LParen expression_list RParen .)


state 129

    (72) expression_list -> expression_list expression_item .

    RParen          reduce using rule 72 (expression_list -> expression_list expression_item .)
    Comma           reduce using rule 72 (expression_list -> expression_list expression_item .)
    Identifier      reduce using rule 72 (expression_list -> expression_list expression_item .)
    Minus           reduce using rule 72 (expression_list -> expression_list expression_item .)
    BitNot          reduce using rule 72 (expression_list -> expression_list expression_item .)
    Not             reduce using rule 72 (expression_list -> expression_list expression_item .)
    Integer         reduce using rule 72 (expression_list -> expression_list expression_item .)
    LParen          reduce using rule 72 (expression_list -> expression_list expression_item .)


state 130

    (74) expression_item -> Comma . expression
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 141
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 131

    (75) expression_item -> expression .

    RParen          reduce using rule 75 (expression_item -> expression .)
    Comma           reduce using rule 75 (expression_item -> expression .)
    Identifier      reduce using rule 75 (expression_item -> expression .)
    Minus           reduce using rule 75 (expression_item -> expression .)
    BitNot          reduce using rule 75 (expression_item -> expression .)
    Not             reduce using rule 75 (expression_item -> expression .)
    Integer         reduce using rule 75 (expression_item -> expression .)
    LParen          reduce using rule 75 (expression_item -> expression .)


state 132

    (17) statement_matched -> If LParen expression RParen . statement_matched Else statement_matched
    (18) statement_unmatched -> If LParen expression RParen . statement_matched Else statement_unmatched
    (19) statement_unmatched -> If LParen expression RParen . statement
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (15) statement -> . statement_matched
    (16) statement -> . statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 31
    statement_matched              shift and go to state 142
    statement_unmatched            shift and go to state 30
    statement                      shift and go to state 143
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 133

    (20) statement_matched -> While LParen expression RParen . statement_matched
    (21) statement_unmatched -> While LParen expression RParen . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 31
    statement_matched              shift and go to state 144
    statement_unmatched            shift and go to state 145
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 134

    (22) statement_matched -> Do statement_matched While expression . Semi

    Semi            shift and go to state 146


state 135

    (23) statement_unmatched -> Do statement_unmatched While expression . Semi

    Semi            shift and go to state 147


state 136

    (24) statement_matched -> For LParen expression Semi . expression Semi expression RParen statement_matched
    (30) statement_matched -> For LParen expression Semi . Semi expression RParen statement_matched
    (34) statement_matched -> For LParen expression Semi . expression Semi RParen statement_matched
    (38) statement_matched -> For LParen expression Semi . Semi RParen statement_matched
    (26) statement_unmatched -> For LParen expression Semi . expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> For LParen expression Semi . Semi expression RParen statement_unmatched
    (36) statement_unmatched -> For LParen expression Semi . expression Semi RParen statement_unmatched
    (40) statement_unmatched -> For LParen expression Semi . Semi RParen statement_unmatched
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Semi            shift and go to state 149
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 148
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 137

    (44) statement_matched -> For LParen Semi Semi . expression RParen statement_matched
    (46) statement_matched -> For LParen Semi Semi . RParen statement_matched
    (45) statement_unmatched -> For LParen Semi Semi . expression RParen statement_unmatched
    (47) statement_unmatched -> For LParen Semi Semi . RParen statement_unmatched
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    RParen          shift and go to state 151
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 150
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 138

    (28) statement_matched -> For LParen Semi expression . Semi expression RParen statement_matched
    (42) statement_matched -> For LParen Semi expression . Semi RParen statement_matched
    (29) statement_unmatched -> For LParen Semi expression . Semi expression RParen statement_unmatched
    (43) statement_unmatched -> For LParen Semi expression . Semi RParen statement_unmatched

    Semi            shift and go to state 152


state 139

    (25) statement_matched -> For LParen declaration Semi . expression Semi expression RParen statement_matched
    (31) statement_matched -> For LParen declaration Semi . Semi expression RParen statement_matched
    (35) statement_matched -> For LParen declaration Semi . expression Semi RParen statement_matched
    (39) statement_matched -> For LParen declaration Semi . Semi RParen statement_matched
    (27) statement_unmatched -> For LParen declaration Semi . expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> For LParen declaration Semi . Semi expression RParen statement_unmatched
    (37) statement_unmatched -> For LParen declaration Semi . expression Semi RParen statement_unmatched
    (41) statement_unmatched -> For LParen declaration Semi . Semi RParen statement_unmatched
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Semi            shift and go to state 153
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 154
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 140

    (96) conditional -> logical_or Question expression Colon . conditional
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Identifier      shift and go to state 93
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    logical_or                     shift and go to state 43
    conditional                    shift and go to state 155
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 141

    (74) expression_item -> Comma expression .

    RParen          reduce using rule 74 (expression_item -> Comma expression .)
    Comma           reduce using rule 74 (expression_item -> Comma expression .)
    Identifier      reduce using rule 74 (expression_item -> Comma expression .)
    Minus           reduce using rule 74 (expression_item -> Comma expression .)
    BitNot          reduce using rule 74 (expression_item -> Comma expression .)
    Not             reduce using rule 74 (expression_item -> Comma expression .)
    Integer         reduce using rule 74 (expression_item -> Comma expression .)
    LParen          reduce using rule 74 (expression_item -> Comma expression .)


state 142

    (17) statement_matched -> If LParen expression RParen statement_matched . Else statement_matched
    (18) statement_unmatched -> If LParen expression RParen statement_matched . Else statement_unmatched
    (15) statement -> statement_matched .

    Else            shift and go to state 156
    RBrace          reduce using rule 15 (statement -> statement_matched .)
    If              reduce using rule 15 (statement -> statement_matched .)
    While           reduce using rule 15 (statement -> statement_matched .)
    Do              reduce using rule 15 (statement -> statement_matched .)
    For             reduce using rule 15 (statement -> statement_matched .)
    Return          reduce using rule 15 (statement -> statement_matched .)
    LBrace          reduce using rule 15 (statement -> statement_matched .)
    Break           reduce using rule 15 (statement -> statement_matched .)
    Continue        reduce using rule 15 (statement -> statement_matched .)
    Int             reduce using rule 15 (statement -> statement_matched .)
    Identifier      reduce using rule 15 (statement -> statement_matched .)
    Minus           reduce using rule 15 (statement -> statement_matched .)
    BitNot          reduce using rule 15 (statement -> statement_matched .)
    Not             reduce using rule 15 (statement -> statement_matched .)
    Integer         reduce using rule 15 (statement -> statement_matched .)
    LParen          reduce using rule 15 (statement -> statement_matched .)
    Semi            reduce using rule 15 (statement -> statement_matched .)


state 143

    (19) statement_unmatched -> If LParen expression RParen statement .

    RBrace          reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    If              reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    While           reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    Do              reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    For             reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    Return          reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    LBrace          reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    Break           reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    Continue        reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    Int             reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    Identifier      reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    Minus           reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    BitNot          reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    Not             reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    Integer         reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    LParen          reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)
    Semi            reduce using rule 19 (statement_unmatched -> If LParen expression RParen statement .)


state 144

    (20) statement_matched -> While LParen expression RParen statement_matched .

    RBrace          reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    If              reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    While           reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    Do              reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    For             reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    Return          reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    LBrace          reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    Break           reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    Continue        reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    Int             reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    Identifier      reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    Minus           reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    BitNot          reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    Not             reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    Integer         reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    LParen          reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    Semi            reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)
    Else            reduce using rule 20 (statement_matched -> While LParen expression RParen statement_matched .)


state 145

    (21) statement_unmatched -> While LParen expression RParen statement_unmatched .

    RBrace          reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    If              reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    While           reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Do              reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    For             reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Return          reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LBrace          reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Break           reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Continue        reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Int             reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Identifier      reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Minus           reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    BitNot          reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Not             reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Integer         reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LParen          reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Semi            reduce using rule 21 (statement_unmatched -> While LParen expression RParen statement_unmatched .)


state 146

    (22) statement_matched -> Do statement_matched While expression Semi .

    RBrace          reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    If              reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    While           reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    Do              reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    For             reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    Return          reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    LBrace          reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    Break           reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    Continue        reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    Int             reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    Identifier      reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    Minus           reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    BitNot          reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    Not             reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    Integer         reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    LParen          reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    Semi            reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)
    Else            reduce using rule 22 (statement_matched -> Do statement_matched While expression Semi .)


state 147

    (23) statement_unmatched -> Do statement_unmatched While expression Semi .

    RBrace          reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    If              reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    While           reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    Do              reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    For             reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    Return          reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    LBrace          reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    Break           reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    Continue        reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    Int             reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    Identifier      reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    Minus           reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    BitNot          reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    Not             reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    Integer         reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    LParen          reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)
    Semi            reduce using rule 23 (statement_unmatched -> Do statement_unmatched While expression Semi .)


state 148

    (24) statement_matched -> For LParen expression Semi expression . Semi expression RParen statement_matched
    (34) statement_matched -> For LParen expression Semi expression . Semi RParen statement_matched
    (26) statement_unmatched -> For LParen expression Semi expression . Semi expression RParen statement_unmatched
    (36) statement_unmatched -> For LParen expression Semi expression . Semi RParen statement_unmatched

    Semi            shift and go to state 157


state 149

    (30) statement_matched -> For LParen expression Semi Semi . expression RParen statement_matched
    (38) statement_matched -> For LParen expression Semi Semi . RParen statement_matched
    (32) statement_unmatched -> For LParen expression Semi Semi . expression RParen statement_unmatched
    (40) statement_unmatched -> For LParen expression Semi Semi . RParen statement_unmatched
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    RParen          shift and go to state 159
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 158
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 150

    (44) statement_matched -> For LParen Semi Semi expression . RParen statement_matched
    (45) statement_unmatched -> For LParen Semi Semi expression . RParen statement_unmatched

    RParen          shift and go to state 160


state 151

    (46) statement_matched -> For LParen Semi Semi RParen . statement_matched
    (47) statement_unmatched -> For LParen Semi Semi RParen . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    statement_matched              shift and go to state 161
    statement_unmatched            shift and go to state 162
    expression                     shift and go to state 31
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 152

    (28) statement_matched -> For LParen Semi expression Semi . expression RParen statement_matched
    (42) statement_matched -> For LParen Semi expression Semi . RParen statement_matched
    (29) statement_unmatched -> For LParen Semi expression Semi . expression RParen statement_unmatched
    (43) statement_unmatched -> For LParen Semi expression Semi . RParen statement_unmatched
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    RParen          shift and go to state 164
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 163
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 153

    (31) statement_matched -> For LParen declaration Semi Semi . expression RParen statement_matched
    (39) statement_matched -> For LParen declaration Semi Semi . RParen statement_matched
    (33) statement_unmatched -> For LParen declaration Semi Semi . expression RParen statement_unmatched
    (41) statement_unmatched -> For LParen declaration Semi Semi . RParen statement_unmatched
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    RParen          shift and go to state 166
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 165
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 154

    (25) statement_matched -> For LParen declaration Semi expression . Semi expression RParen statement_matched
    (35) statement_matched -> For LParen declaration Semi expression . Semi RParen statement_matched
    (27) statement_unmatched -> For LParen declaration Semi expression . Semi expression RParen statement_unmatched
    (37) statement_unmatched -> For LParen declaration Semi expression . Semi RParen statement_unmatched

    Semi            shift and go to state 167


state 155

    (96) conditional -> logical_or Question expression Colon conditional .

    Semi            reduce using rule 96 (conditional -> logical_or Question expression Colon conditional .)
    RParen          reduce using rule 96 (conditional -> logical_or Question expression Colon conditional .)
    Comma           reduce using rule 96 (conditional -> logical_or Question expression Colon conditional .)
    Int             reduce using rule 96 (conditional -> logical_or Question expression Colon conditional .)
    Colon           reduce using rule 96 (conditional -> logical_or Question expression Colon conditional .)
    Identifier      reduce using rule 96 (conditional -> logical_or Question expression Colon conditional .)
    Minus           reduce using rule 96 (conditional -> logical_or Question expression Colon conditional .)
    BitNot          reduce using rule 96 (conditional -> logical_or Question expression Colon conditional .)
    Not             reduce using rule 96 (conditional -> logical_or Question expression Colon conditional .)
    Integer         reduce using rule 96 (conditional -> logical_or Question expression Colon conditional .)
    LParen          reduce using rule 96 (conditional -> logical_or Question expression Colon conditional .)


state 156

    (17) statement_matched -> If LParen expression RParen statement_matched Else . statement_matched
    (18) statement_unmatched -> If LParen expression RParen statement_matched Else . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 31
    statement_matched              shift and go to state 168
    statement_unmatched            shift and go to state 169
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 157

    (24) statement_matched -> For LParen expression Semi expression Semi . expression RParen statement_matched
    (34) statement_matched -> For LParen expression Semi expression Semi . RParen statement_matched
    (26) statement_unmatched -> For LParen expression Semi expression Semi . expression RParen statement_unmatched
    (36) statement_unmatched -> For LParen expression Semi expression Semi . RParen statement_unmatched
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    RParen          shift and go to state 171
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 170
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 158

    (30) statement_matched -> For LParen expression Semi Semi expression . RParen statement_matched
    (32) statement_unmatched -> For LParen expression Semi Semi expression . RParen statement_unmatched

    RParen          shift and go to state 172


state 159

    (38) statement_matched -> For LParen expression Semi Semi RParen . statement_matched
    (40) statement_unmatched -> For LParen expression Semi Semi RParen . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 31
    statement_matched              shift and go to state 173
    statement_unmatched            shift and go to state 174
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 160

    (44) statement_matched -> For LParen Semi Semi expression RParen . statement_matched
    (45) statement_unmatched -> For LParen Semi Semi expression RParen . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 31
    statement_matched              shift and go to state 175
    statement_unmatched            shift and go to state 176
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 161

    (46) statement_matched -> For LParen Semi Semi RParen statement_matched .

    RBrace          reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    If              reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    While           reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Do              reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    For             reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Return          reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    LBrace          reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Break           reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Continue        reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Int             reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Identifier      reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Minus           reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    BitNot          reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Not             reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Integer         reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    LParen          reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Semi            reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Else            reduce using rule 46 (statement_matched -> For LParen Semi Semi RParen statement_matched .)


state 162

    (47) statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .

    RBrace          reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    If              reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    While           reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Do              reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    For             reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Return          reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    LBrace          reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Break           reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Continue        reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Int             reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Identifier      reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Minus           reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    BitNot          reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Not             reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Integer         reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    LParen          reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Semi            reduce using rule 47 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)


state 163

    (28) statement_matched -> For LParen Semi expression Semi expression . RParen statement_matched
    (29) statement_unmatched -> For LParen Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 177


state 164

    (42) statement_matched -> For LParen Semi expression Semi RParen . statement_matched
    (43) statement_unmatched -> For LParen Semi expression Semi RParen . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 31
    statement_matched              shift and go to state 178
    statement_unmatched            shift and go to state 179
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 165

    (31) statement_matched -> For LParen declaration Semi Semi expression . RParen statement_matched
    (33) statement_unmatched -> For LParen declaration Semi Semi expression . RParen statement_unmatched

    RParen          shift and go to state 180


state 166

    (39) statement_matched -> For LParen declaration Semi Semi RParen . statement_matched
    (41) statement_unmatched -> For LParen declaration Semi Semi RParen . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    statement_matched              shift and go to state 181
    statement_unmatched            shift and go to state 182
    expression                     shift and go to state 31
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 167

    (25) statement_matched -> For LParen declaration Semi expression Semi . expression RParen statement_matched
    (35) statement_matched -> For LParen declaration Semi expression Semi . RParen statement_matched
    (27) statement_unmatched -> For LParen declaration Semi expression Semi . expression RParen statement_unmatched
    (37) statement_unmatched -> For LParen declaration Semi expression Semi . RParen statement_unmatched
    (57) expression -> . assignment
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    RParen          shift and go to state 184
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 183
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 168

    (17) statement_matched -> If LParen expression RParen statement_matched Else statement_matched .

    RBrace          reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    If              reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    While           reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Do              reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    For             reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Return          reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LBrace          reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Break           reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Continue        reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Int             reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Identifier      reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Minus           reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    BitNot          reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Not             reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Integer         reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LParen          reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Semi            reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Else            reduce using rule 17 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)


state 169

    (18) statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .

    RBrace          reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    If              reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    While           reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Do              reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    For             reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Return          reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LBrace          reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Break           reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Continue        reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Int             reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Identifier      reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Minus           reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    BitNot          reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Not             reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Integer         reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LParen          reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Semi            reduce using rule 18 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)


state 170

    (24) statement_matched -> For LParen expression Semi expression Semi expression . RParen statement_matched
    (26) statement_unmatched -> For LParen expression Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 185


state 171

    (34) statement_matched -> For LParen expression Semi expression Semi RParen . statement_matched
    (36) statement_unmatched -> For LParen expression Semi expression Semi RParen . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 31
    statement_matched              shift and go to state 186
    statement_unmatched            shift and go to state 187
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 172

    (30) statement_matched -> For LParen expression Semi Semi expression RParen . statement_matched
    (32) statement_unmatched -> For LParen expression Semi Semi expression RParen . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 31
    statement_matched              shift and go to state 188
    statement_unmatched            shift and go to state 189
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 173

    (38) statement_matched -> For LParen expression Semi Semi RParen statement_matched .

    RBrace          reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    If              reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    While           reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Do              reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    For             reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Return          reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    LBrace          reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Break           reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Continue        reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Int             reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Identifier      reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Minus           reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    BitNot          reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Not             reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Integer         reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    LParen          reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Semi            reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Else            reduce using rule 38 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)


state 174

    (40) statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .

    RBrace          reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    If              reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    While           reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Do              reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    For             reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Return          reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    LBrace          reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Break           reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Continue        reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Int             reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Identifier      reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Minus           reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    BitNot          reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Not             reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Integer         reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    LParen          reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Semi            reduce using rule 40 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)


state 175

    (44) statement_matched -> For LParen Semi Semi expression RParen statement_matched .

    RBrace          reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    If              reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    While           reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Do              reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    For             reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Return          reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    LBrace          reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Break           reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Continue        reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Int             reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Identifier      reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Minus           reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    BitNot          reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Not             reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Integer         reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    LParen          reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Semi            reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Else            reduce using rule 44 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)


state 176

    (45) statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    If              reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    While           reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Do              reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    For             reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Return          reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Break           reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Int             reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Not             reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 45 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)


state 177

    (28) statement_matched -> For LParen Semi expression Semi expression RParen . statement_matched
    (29) statement_unmatched -> For LParen Semi expression Semi expression RParen . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 31
    statement_matched              shift and go to state 190
    statement_unmatched            shift and go to state 191
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 178

    (42) statement_matched -> For LParen Semi expression Semi RParen statement_matched .

    RBrace          reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    If              reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    While           reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Do              reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    For             reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Return          reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    LBrace          reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Break           reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Continue        reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Int             reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Identifier      reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Minus           reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    BitNot          reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Not             reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Integer         reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    LParen          reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Semi            reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Else            reduce using rule 42 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)


state 179

    (43) statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .

    RBrace          reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    If              reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    While           reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Do              reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    For             reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Return          reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    LBrace          reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Break           reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Continue        reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Int             reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Identifier      reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Minus           reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    BitNot          reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Not             reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Integer         reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    LParen          reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Semi            reduce using rule 43 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)


state 180

    (31) statement_matched -> For LParen declaration Semi Semi expression RParen . statement_matched
    (33) statement_unmatched -> For LParen declaration Semi Semi expression RParen . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 31
    statement_matched              shift and go to state 192
    statement_unmatched            shift and go to state 193
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 181

    (39) statement_matched -> For LParen declaration Semi Semi RParen statement_matched .

    RBrace          reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    If              reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    While           reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Do              reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    For             reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Return          reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    LBrace          reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Break           reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Continue        reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Int             reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Identifier      reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Minus           reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    BitNot          reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Not             reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Integer         reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    LParen          reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Semi            reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Else            reduce using rule 39 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)


state 182

    (41) statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .

    RBrace          reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    If              reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    While           reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Do              reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    For             reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Return          reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    LBrace          reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Break           reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Continue        reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Int             reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Identifier      reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Minus           reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    BitNot          reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Not             reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Integer         reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    LParen          reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Semi            reduce using rule 41 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)


state 183

    (25) statement_matched -> For LParen declaration Semi expression Semi expression . RParen statement_matched
    (27) statement_unmatched -> For LParen declaration Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 194


state 184

    (35) statement_matched -> For LParen declaration Semi expression Semi RParen . statement_matched
    (37) statement_unmatched -> For LParen declaration Semi expression Semi RParen . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 31
    statement_matched              shift and go to state 195
    statement_unmatched            shift and go to state 196
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 185

    (24) statement_matched -> For LParen expression Semi expression Semi expression RParen . statement_matched
    (26) statement_unmatched -> For LParen expression Semi expression Semi expression RParen . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 31
    statement_matched              shift and go to state 197
    statement_unmatched            shift and go to state 198
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 186

    (34) statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .

    RBrace          reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    If              reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    While           reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Do              reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    For             reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Return          reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    LBrace          reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Break           reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Continue        reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Int             reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Identifier      reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Minus           reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    BitNot          reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Not             reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Integer         reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    LParen          reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Semi            reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Else            reduce using rule 34 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)


state 187

    (36) statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .

    RBrace          reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    If              reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    While           reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Do              reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    For             reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Return          reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    LBrace          reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Break           reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Continue        reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Int             reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Identifier      reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Minus           reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    BitNot          reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Not             reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Integer         reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    LParen          reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Semi            reduce using rule 36 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)


state 188

    (30) statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .

    RBrace          reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    If              reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    While           reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Do              reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    For             reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Return          reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    LBrace          reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Break           reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Continue        reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Int             reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Identifier      reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Minus           reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    BitNot          reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Not             reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Integer         reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    LParen          reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Semi            reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Else            reduce using rule 30 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)


state 189

    (32) statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    If              reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    While           reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Do              reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    For             reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Return          reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Break           reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Int             reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Not             reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 32 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)


state 190

    (28) statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Do              reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 28 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)


state 191

    (29) statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Do              reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 29 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)


state 192

    (31) statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .

    RBrace          reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    If              reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    While           reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Do              reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    For             reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Return          reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    LBrace          reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Break           reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Continue        reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Int             reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Identifier      reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Minus           reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    BitNot          reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Not             reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Integer         reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    LParen          reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Semi            reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Else            reduce using rule 31 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)


state 193

    (33) statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    If              reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    While           reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Do              reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    For             reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Return          reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Break           reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Int             reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Not             reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 33 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)


state 194

    (25) statement_matched -> For LParen declaration Semi expression Semi expression RParen . statement_matched
    (27) statement_unmatched -> For LParen declaration Semi expression Semi expression RParen . statement_unmatched
    (17) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (20) statement_matched -> . While LParen expression RParen statement_matched
    (22) statement_matched -> . Do statement_matched While expression Semi
    (24) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (25) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (28) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (30) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (31) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (42) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (44) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (48) statement_matched -> . Return expression Semi
    (49) statement_matched -> . opt_expression Semi
    (50) statement_matched -> . LBrace block RBrace
    (51) statement_matched -> . Break Semi
    (52) statement_matched -> . Continue Semi
    (18) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (19) statement_unmatched -> . If LParen expression RParen statement
    (21) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (23) statement_unmatched -> . Do statement_unmatched While expression Semi
    (26) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (27) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (29) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (32) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (43) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) opt_expression -> . expression
    (54) opt_expression -> . empty
    (57) expression -> . assignment
    (1) empty -> .
    (58) assignment -> . conditional
    (79) assignment -> . Identifier Assign expression
    (59) conditional -> . logical_or
    (96) conditional -> . logical_or Question expression Colon conditional
    (60) logical_or -> . logical_and
    (80) logical_or -> . logical_or Or logical_and
    (61) logical_and -> . bit_or
    (81) logical_and -> . logical_and And bit_or
    (62) bit_or -> . xor
    (82) bit_or -> . bit_or BitOr xor
    (63) xor -> . bit_and
    (83) xor -> . xor Xor bit_and
    (64) bit_and -> . equality
    (84) bit_and -> . bit_and BitAnd equality
    (65) equality -> . relational
    (85) equality -> . equality NotEqual relational
    (86) equality -> . equality Equal relational
    (66) relational -> . additive
    (87) relational -> . relational Less additive
    (88) relational -> . relational Greater additive
    (89) relational -> . relational LessEqual additive
    (90) relational -> . relational GreaterEqual additive
    (67) additive -> . multiplicative
    (91) additive -> . additive Plus multiplicative
    (92) additive -> . additive Minus multiplicative
    (68) multiplicative -> . unary
    (93) multiplicative -> . multiplicative Mul unary
    (94) multiplicative -> . multiplicative Div unary
    (95) multiplicative -> . multiplicative Mod unary
    (69) unary -> . postfix
    (76) unary -> . Minus unary
    (77) unary -> . BitNot unary
    (78) unary -> . Not unary
    (70) postfix -> . primary
    (71) postfix -> . Identifier LParen expression_list RParen
    (97) primary -> . Integer
    (98) primary -> . Identifier
    (99) primary -> . LParen expression RParen

    If              shift and go to state 32
    While           shift and go to state 33
    Do              shift and go to state 34
    For             shift and go to state 35
    Return          shift and go to state 36
    LBrace          shift and go to state 24
    Break           shift and go to state 38
    Continue        shift and go to state 39
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 22
    Minus           shift and go to state 52
    BitNot          shift and go to state 55
    Not             shift and go to state 56
    Integer         shift and go to state 58
    LParen          shift and go to state 23

    expression                     shift and go to state 31
    statement_matched              shift and go to state 199
    statement_unmatched            shift and go to state 200
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 40
    assignment                     shift and go to state 41
    conditional                    shift and go to state 42
    logical_or                     shift and go to state 43
    logical_and                    shift and go to state 44
    bit_or                         shift and go to state 45
    xor                            shift and go to state 46
    bit_and                        shift and go to state 47
    equality                       shift and go to state 48
    relational                     shift and go to state 49
    additive                       shift and go to state 50
    multiplicative                 shift and go to state 51
    unary                          shift and go to state 53
    postfix                        shift and go to state 54
    primary                        shift and go to state 57

state 195

    (35) statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .

    RBrace          reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    If              reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    While           reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Do              reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    For             reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Return          reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    LBrace          reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Break           reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Continue        reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Int             reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Identifier      reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Minus           reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    BitNot          reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Not             reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Integer         reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    LParen          reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Semi            reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Else            reduce using rule 35 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)


state 196

    (37) statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .

    RBrace          reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    If              reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    While           reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Do              reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    For             reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Return          reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    LBrace          reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Break           reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Continue        reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Int             reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Identifier      reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Minus           reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    BitNot          reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Not             reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Integer         reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    LParen          reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Semi            reduce using rule 37 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)


state 197

    (24) statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Do              reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 24 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)


state 198

    (26) statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Do              reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 26 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)


state 199

    (25) statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Do              reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 25 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)


state 200

    (27) statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Do              reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 27 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RParen in state 7 resolved as shift
WARNING: shift/reduce conflict for LParen in state 22 resolved as shift
WARNING: shift/reduce conflict for Minus in state 50 resolved as shift
WARNING: shift/reduce conflict for LParen in state 93 resolved as shift
WARNING: shift/reduce conflict for Minus in state 119 resolved as shift
WARNING: shift/reduce conflict for Minus in state 120 resolved as shift
WARNING: shift/reduce conflict for Minus in state 121 resolved as shift
WARNING: shift/reduce conflict for Minus in state 122 resolved as shift
